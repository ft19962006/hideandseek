var M=Object.defineProperty;var b=(c,t,e)=>t in c?M(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var n=(c,t,e)=>b(c,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const a of i)if(a.type==="childList")for(const r of a.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function e(i){const a={};return i.integrity&&(a.integrity=i.integrity),i.referrerPolicy&&(a.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?a.credentials="include":i.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(i){if(i.ep)return;i.ep=!0;const a=e(i);fetch(i.href,a)}})();const m={canvas:{width:800,height:600},player:{walkSpeed:100,runSpeed:200,initialMoney:100,initialStamina:100,maxStamina:100},stamina:{idleRecoveryPerSecond:2,transportRecoveryPerSecond:1,exhaustedSpeedMultiplier:.5},transport:{bus:{speed:200,cost:10,waitTime:3},metro:{speed:300,cost:20,waitTime:5},taxi:{speed:250,cost:30,waitTime:0}}},x={fill:"#E91E63",stroke:"#880E4F"},S={road:"#424242",building:"#757575",grass:"#81C784",stop:"#FFF176",grid:"#333333",wall:"#000000"},p={WIDTH:21,HEIGHT:21,TILE_SIZE:32},w={TARGET_TIME:30},f={SPEED:80,COUNT:2,MIN_SPAWN_DISTANCE:8};class T{constructor(){n(this,"lastTime",0);n(this,"accumulatedTime",0);n(this,"fixedTimeStep",1e3/60);n(this,"animationFrameId",null);n(this,"isRunning",!1);n(this,"updateCallbacks",[]);n(this,"renderCallbacks",[]);n(this,"fps",0);n(this,"frameCount",0);n(this,"fpsUpdateTime",0);this.loop=this.loop.bind(this)}onUpdate(t){this.updateCallbacks.push(t)}onRender(t){this.renderCallbacks.push(t)}offUpdate(t){const e=this.updateCallbacks.indexOf(t);e>-1&&this.updateCallbacks.splice(e,1)}offRender(t){const e=this.renderCallbacks.indexOf(t);e>-1&&this.renderCallbacks.splice(e,1)}start(){this.isRunning||(this.isRunning=!0,this.lastTime=performance.now(),this.accumulatedTime=0,this.fpsUpdateTime=this.lastTime,this.frameCount=0,this.animationFrameId=requestAnimationFrame(this.loop),console.log("[GameLoop] Started"))}stop(){this.isRunning&&(this.isRunning=!1,this.animationFrameId!==null&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null),console.log("[GameLoop] Stopped"))}loop(t){if(!this.isRunning)return;const e=t-this.lastTime;for(this.lastTime=t,this.accumulatedTime+=e;this.accumulatedTime>=this.fixedTimeStep;){const s=this.fixedTimeStep/1e3;for(const i of this.updateCallbacks)i(s);this.accumulatedTime-=this.fixedTimeStep}for(const s of this.renderCallbacks)s();this.frameCount++,t-this.fpsUpdateTime>=1e3&&(this.fps=this.frameCount,this.frameCount=0,this.fpsUpdateTime=t),this.animationFrameId=requestAnimationFrame(this.loop)}getFPS(){return this.fps}getIsRunning(){return this.isRunning}}class P{constructor(){n(this,"state",{up:!1,down:!1,left:!1,right:!1,run:!1,interact:!1,pause:!1,map:!1,restart:!1});n(this,"justPressed",new Set);n(this,"keyMap",{KeyW:"up",ArrowUp:"up",KeyS:"down",ArrowDown:"down",KeyA:"left",ArrowLeft:"left",KeyD:"right",ArrowRight:"right",ShiftLeft:"run",ShiftRight:"run",KeyE:"interact",Space:"restart",KeyR:"restart",Escape:"pause",KeyM:"map"});this.handleKeyDown=this.handleKeyDown.bind(this),this.handleKeyUp=this.handleKeyUp.bind(this)}init(){window.addEventListener("keydown",this.handleKeyDown),window.addEventListener("keyup",this.handleKeyUp),console.log("[InputHandler] Initialized")}destroy(){window.removeEventListener("keydown",this.handleKeyDown),window.removeEventListener("keyup",this.handleKeyUp),console.log("[InputHandler] Destroyed")}handleKeyDown(t){const e=this.keyMap[t.code];e&&(t.preventDefault(),!t.repeat&&!this.state[e]&&this.justPressed.add(e),this.state[e]=!0)}handleKeyUp(t){const e=this.keyMap[t.code];e&&(t.preventDefault(),this.state[e]=!1)}getState(){return{...this.state}}isPressed(t){return this.state[t]}isJustPressed(t){return this.justPressed.has(t)}clearJustPressed(){this.justPressed.clear()}getMovementVector(){let t=0,e=0;if(this.state.left&&(t-=1),this.state.right&&(t+=1),this.state.up&&(e-=1),this.state.down&&(e+=1),t!==0&&e!==0){const s=Math.sqrt(t*t+e*e);t/=s,e/=s}return{x:t,y:e}}isMoving(){return this.state.up||this.state.down||this.state.left||this.state.right}}class E{constructor(){n(this,"currentStamina");n(this,"maxStamina");n(this,"isExhausted",!1);n(this,"changeCallbacks",[]);this.currentStamina=m.player.initialStamina,this.maxStamina=m.player.maxStamina}init(t){this.maxStamina=t??m.player.maxStamina,this.currentStamina=this.maxStamina,this.isExhausted=!1,this.notifyChange(),console.log(`[StaminaSystem] Initialized with ${this.maxStamina} max stamina`)}update(t,e){const s=m.stamina;let i=0;switch(e){case"idle":i=s.idleRecoveryPerSecond*t;break;case"walking":i=-1*t;break;case"running":i=-3*t;break;case"onTransport":i=s.transportRecoveryPerSecond*t;break}i!==0&&this.modifyStamina(i)}modifyStamina(t){const e=this.currentStamina;this.currentStamina=Math.max(0,Math.min(this.maxStamina,this.currentStamina+t)),this.currentStamina<=0&&!this.isExhausted?(this.isExhausted=!0,console.log("[StaminaSystem] Player is exhausted!")):this.currentStamina>20&&this.isExhausted&&(this.isExhausted=!1,console.log("[StaminaSystem] Player recovered from exhaustion")),Math.abs(e-this.currentStamina)>.01&&this.notifyChange()}consume(t){return this.currentStamina>=t?(this.modifyStamina(-t),!0):!1}recover(t){this.modifyStamina(t)}getCurrentStamina(){return this.currentStamina}getMaxStamina(){return this.maxStamina}getStaminaPercent(){return this.currentStamina/this.maxStamina}getIsExhausted(){return this.isExhausted}getSpeedMultiplier(){return this.isExhausted?m.stamina.exhaustedSpeedMultiplier:1}onChange(t){this.changeCallbacks.push(t)}offChange(t){const e=this.changeCallbacks.indexOf(t);e>-1&&this.changeCallbacks.splice(e,1)}notifyChange(){for(const t of this.changeCallbacks)t(this.currentStamina,this.maxStamina)}}class I{constructor(){n(this,"balance");n(this,"changeCallbacks",[]);this.balance=m.player.initialMoney}init(t){this.balance=t??m.player.initialMoney,this.notifyChange(0),console.log(`[MoneySystem] Initialized with $${this.balance}`)}spend(t){return t<=0?(console.warn("[MoneySystem] Invalid spend amount:",t),!1):this.balance>=t?(this.balance-=t,this.notifyChange(-t),console.log(`[MoneySystem] Spent $${t}, balance: $${this.balance}`),!0):(console.log(`[MoneySystem] Insufficient funds. Need $${t}, have $${this.balance}`),!1)}earn(t){if(t<=0){console.warn("[MoneySystem] Invalid earn amount:",t);return}this.balance+=t,this.notifyChange(t),console.log(`[MoneySystem] Earned $${t}, balance: $${this.balance}`)}getBalance(){return this.balance}canAfford(t){return this.balance>=t}getTransportCost(t){return m.transport[t].cost}canAffordTransport(t){return this.canAfford(this.getTransportCost(t))}payForTransport(t){const e=this.getTransportCost(t);return this.spend(e)}onChange(t){this.changeCallbacks.push(t)}offChange(t){const e=this.changeCallbacks.indexOf(t);e>-1&&this.changeCallbacks.splice(e,1)}notifyChange(t){for(const e of this.changeCallbacks)e(this.balance,t)}}class F{constructor(t,e,s){n(this,"player");n(this,"staminaSystem");n(this,"moneySystem");n(this,"inputHandler");n(this,"mapSystem",null);this.staminaSystem=t,this.moneySystem=e,this.inputHandler=s;const i=m.player;this.player={id:"player-1",position:{x:0,y:0},velocity:{x:0,y:0},state:"idle",direction:"down",stamina:i.initialStamina,maxStamina:i.maxStamina,money:i.initialMoney,currentTransport:null,movementSpeed:i.walkSpeed}}setMapSystem(t){this.mapSystem=t}init(t){t&&(this.player.position={...t}),this.player.state="idle",this.player.velocity={x:0,y:0},this.player.currentTransport=null,console.log("[PlayerSystem] Initialized at position:",this.player.position)}update(t){if(this.player.state==="onTransport"||this.player.state==="boarding")return;const e=this.inputHandler.getMovementVector(),s=this.inputHandler.isPressed("run");if(this.inputHandler.isMoving()){const a=s&&!this.staminaSystem.getIsExhausted();this.player.state=a?"running":"walking";const o=(a?m.player.runSpeed:m.player.walkSpeed)*this.staminaSystem.getSpeedMultiplier();this.player.velocity.x=e.x*o,this.player.velocity.y=e.y*o,this.updateDirection(e)}else this.player.state="idle",this.player.velocity.x=0,this.player.velocity.y=0;this.staminaSystem.update(t,this.player.state),this.updatePosition(t),this.player.stamina=this.staminaSystem.getCurrentStamina(),this.player.money=this.moneySystem.getBalance()}updateDirection(t){Math.abs(t.x)>Math.abs(t.y)?this.player.direction=t.x>0?"right":"left":t.y!==0&&(this.player.direction=t.y>0?"down":"up")}updatePosition(t){const e=p.TILE_SIZE,s=p.WIDTH*e,i=p.HEIGHT*e,a=10,r=this.player.position.x,o=this.player.position.y;let l=r+this.player.velocity.x*t,h=o+this.player.velocity.y*t;if(l=Math.max(a,Math.min(s-a,l)),h=Math.max(a,Math.min(i-a,h)),!this.mapSystem){this.player.position.x=l,this.player.position.y=h;return}this.canMoveTo(l,o,a,e)&&(this.player.position.x=l),this.canMoveTo(this.player.position.x,h,a,e)&&(this.player.position.y=h)}canMoveTo(t,e,s,i){if(!this.mapSystem)return!0;const a=[{x:t-s,y:e-s},{x:t+s,y:e-s},{x:t-s,y:e+s},{x:t+s,y:e+s}];for(const r of a){const o=Math.floor(r.x/i),l=Math.floor(r.y/i);if(!this.mapSystem.isWalkable(o,l))return!1}return!0}boardTransport(t){return this.player.currentTransport!==null?(console.log("[PlayerSystem] Already on transport"),!1):(this.player.currentTransport=t,this.player.state="boarding",this.player.velocity={x:0,y:0},setTimeout(()=>{this.player.currentTransport===t&&(this.player.state="onTransport")},500),console.log("[PlayerSystem] Boarding transport:",t),!0)}exitTransport(t){if(this.player.currentTransport===null){console.log("[PlayerSystem] Not on any transport");return}this.player.currentTransport=null,this.player.position={...t},this.player.state="idle",console.log("[PlayerSystem] Exited transport at:",t)}setPosition(t){this.player.position={...t}}getPosition(){return{...this.player.position}}getGridPosition(){var e;const t=((e=this.mapSystem)==null?void 0:e.getMapData().tileSize)??p.TILE_SIZE;return{x:Math.floor(this.player.position.x/t),y:Math.floor(this.player.position.y/t)}}getState(){return this.player.state}getDirection(){return this.player.direction}getPlayer(){return{...this.player}}isOnTransport(){return this.player.currentTransport!==null}getCurrentTransportId(){return this.player.currentTransport}}class v{constructor(){n(this,"mapData");this.mapData=this.generateMaze()}generateMaze(){const t=p.WIDTH,e=p.HEIGHT,s=p.TILE_SIZE,i=[];for(let o=0;o<e;o++){i[o]=[];for(let l=0;l<t;l++)i[o][l]={type:"wall",walkable:!1}}const a=1,r=1;return i[r][a]={type:"road",walkable:!0},this.carve(a,r,i,t,e),{width:t,height:e,tileSize:s,tiles:i,stops:[],routes:[]}}carve(t,e,s,i,a){const r=[{dx:0,dy:-2},{dx:0,dy:2},{dx:-2,dy:0},{dx:2,dy:0}].sort(()=>Math.random()-.5);for(const{dx:o,dy:l}of r){const h=t+o,d=e+l;if(h>0&&h<i&&d>0&&d<a&&s[d][h].type==="wall"){const y=t+Math.floor(o/2),u=e+Math.floor(l/2);s[u][y]={type:"road",walkable:!0},s[d][h]={type:"road",walkable:!0},this.carve(h,d,s,i,a)}}}init(){console.log("[MapSystem] Initialized maze map")}getMapData(){return this.mapData}getTile(t,e){return t<0||t>=this.mapData.width||e<0||e>=this.mapData.height?null:this.mapData.tiles[e][t]}getTileAtWorld(t,e){const s=Math.floor(t/this.mapData.tileSize),i=Math.floor(e/this.mapData.tileSize);return this.getTile(s,i)}isWalkable(t,e){const s=this.getTile(t,e);return s?s.walkable:!1}getPlayerSpawnPosition(){return this.gridToWorld(1,1)}gridToWorld(t,e){const s=this.mapData.tileSize;return{x:t*s+s/2,y:e*s+s/2}}worldToGrid(t,e){return{x:Math.floor(t/this.mapData.tileSize),y:Math.floor(e/this.mapData.tileSize)}}getWorldSize(){return{width:this.mapData.width*this.mapData.tileSize,height:this.mapData.height*this.mapData.tileSize}}}class G{constructor(t){}init(){console.log("[TransportSystem] Disabled for Maze Mode")}update(t){}getVehicles(){return[]}getVehicle(t){}getAvailableVehiclesAtStop(t){return[]}boardVehicle(t,e){return!1}exitVehicle(t,e){return null}getVehiclePosition(t){return null}isVehicleAtStop(t){return!1}onEvent(t){}}class z{constructor(){n(this,"enemies",[]);n(this,"mapSystem",null)}setMapSystem(t){this.mapSystem=t}spawnEnemies(t){if(this.enemies=[],!this.mapSystem){console.error("[EnemySystem] MapSystem not set, cannot spawn enemies");return}for(let e=0;e<f.COUNT;e++){const s=this.findValidSpawnPosition(t);if(s){const i={x:s.x,y:s.y,velocityX:0,velocityY:0,speed:f.SPEED,targetX:s.x,targetY:s.y,pathUpdateTimer:0};this.enemies.push(i),console.log(`[EnemySystem] Spawned enemy ${e+1} at (${s.x.toFixed(0)}, ${s.y.toFixed(0)})`)}else console.warn(`[EnemySystem] Could not find valid spawn position for enemy ${e+1}`)}console.log(`[EnemySystem] Spawned ${this.enemies.length} enemies`)}findValidSpawnPosition(t){if(!this.mapSystem)return null;const e=this.mapSystem.getMapData(),s=p.TILE_SIZE,i=f.MIN_SPAWN_DISTANCE,a=Math.floor(t.x/s),r=Math.floor(t.y/s),o=[];for(let h=0;h<e.height;h++)for(let d=0;d<e.width;d++){const y=e.tiles[h][d];if(y.type!=="road"||!y.walkable)continue;const u=Math.abs(d-a),g=Math.abs(h-r);Math.sqrt(u*u+g*g)>=i&&o.push({x:d*s+s/2,y:h*s+s/2})}if(o.length===0)return null;const l=Math.floor(Math.random()*o.length);return o[l]}update(t,e){for(const s of this.enemies)this.updateEnemy(s,e,t)}updateEnemy(t,e,s){const i=e.x-t.x,a=e.y-t.y,r=Math.sqrt(i*i+a*a);if(r>0){const o=i/r,l=a/r,h=t.speed,d=t.x+o*h*s,y=t.y+l*h*s,u=10;this.canMoveTo(d,y,u)?(t.x=d,t.y=y,t.velocityX=o*h,t.velocityY=l*h):this.canMoveTo(d,t.y,u)?(t.x=d,t.velocityX=o*h,t.velocityY=0):this.canMoveTo(t.x,y,u)?(t.y=y,t.velocityX=0,t.velocityY=l*h):(t.velocityX=0,t.velocityY=0),t.targetX=e.x,t.targetY=e.y}}canMoveTo(t,e,s){if(!this.mapSystem)return!1;const i=p.TILE_SIZE,a=[{x:t-s,y:e-s},{x:t+s,y:e-s},{x:t-s,y:e+s},{x:t+s,y:e+s}];for(const r of a){const o=Math.floor(r.x/i),l=Math.floor(r.y/i);if(!this.mapSystem.isWalkable(o,l))return!1}return!0}getEnemies(){return this.enemies}checkPlayerCollision(t,e){for(const i of this.enemies){const a=t.x-i.x,r=t.y-i.y,o=Math.sqrt(a*a+r*r),l=e+10;if(o<l)return!0}return!1}reset(){this.enemies=[]}}class C{constructor(t,e,s,i,a){n(this,"canvas");n(this,"ctx");n(this,"mapSystem");n(this,"playerSystem");n(this,"staminaSystem");n(this,"moneySystem");n(this,"enemySystem",null);n(this,"mazeGameState",null);n(this,"cameraOffset",{x:0,y:0});this.canvas=t;const r=t.getContext("2d");if(!r)throw new Error("Failed to get 2D context");this.ctx=r,this.mapSystem=e,this.playerSystem=s,this.staminaSystem=i,this.moneySystem=a,this.resize(m.canvas.width,m.canvas.height)}resize(t,e){this.canvas.width=t,this.canvas.height=e}setMapSystem(t){this.mapSystem=t}setEnemySystem(t){this.enemySystem=t}setMazeGameState(t){this.mazeGameState=t}render(){this.ctx.fillStyle="#1a1a2e",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.updateCamera(),this.ctx.save(),this.ctx.translate(-this.cameraOffset.x,-this.cameraOffset.y),this.renderMap(),this.renderPlayer(),this.renderEnemies(),this.ctx.restore(),this.renderHUD(),this.renderSurvivalTimer(),this.renderGameOverlay()}updateCamera(){const t=this.playerSystem.getPosition(),e=this.mapSystem.getWorldSize();let s=t.x-this.canvas.width/2,i=t.y-this.canvas.height/2;s=Math.max(0,Math.min(e.width-this.canvas.width,s)),i=Math.max(0,Math.min(e.height-this.canvas.height,i)),this.cameraOffset.x+=(s-this.cameraOffset.x)*.1,this.cameraOffset.y+=(i-this.cameraOffset.y)*.1}renderMap(){const t=this.mapSystem.getMapData(),e=t.tileSize;for(let s=0;s<t.height;s++)for(let i=0;i<t.width;i++){const a=t.tiles[s][i],r=i*e,o=s*e;if(this.isInViewport(r,o,e,e)){switch(a.type){case"road":this.ctx.fillStyle=S.road;break;case"wall":this.ctx.fillStyle=S.wall;break;case"building":this.ctx.fillStyle=S.building;break;case"grass":this.ctx.fillStyle=S.grass;break;case"stop":this.ctx.fillStyle=S.stop;break;default:this.ctx.fillStyle=S.road}this.ctx.fillRect(r,o,e,e),this.ctx.strokeStyle=S.grid,this.ctx.lineWidth=1,this.ctx.strokeRect(r,o,e,e)}}}renderPlayer(){const t=this.playerSystem.getPlayer(),{x:e,y:s}=t.position;this.ctx.save(),this.ctx.fillStyle="rgba(0, 0, 0, 0.3)",this.ctx.beginPath(),this.ctx.ellipse(e,s+12,10,4,0,0,Math.PI*2),this.ctx.fill(),this.ctx.fillStyle=x.fill,this.ctx.strokeStyle=x.stroke,this.ctx.lineWidth=2,this.ctx.beginPath(),this.ctx.arc(e,s,12,0,Math.PI*2),this.ctx.fill(),this.ctx.stroke(),this.renderDirectionIndicator(e,s,t.direction),t.state==="running"&&(this.ctx.strokeStyle="#FFD700",this.ctx.lineWidth=2,this.ctx.setLineDash([4,4]),this.ctx.beginPath(),this.ctx.arc(e,s,16,0,Math.PI*2),this.ctx.stroke(),this.ctx.setLineDash([])),this.ctx.restore()}renderEnemies(){if(!this.enemySystem)return;const t=this.enemySystem.getEnemies();this.ctx.save();for(const e of t)this.ctx.fillStyle="#FF0000",this.ctx.beginPath(),this.ctx.arc(e.x,e.y,12,0,Math.PI*2),this.ctx.fill(),this.ctx.strokeStyle="#FF6666",this.ctx.lineWidth=2,this.ctx.stroke();this.ctx.restore()}renderSurvivalTimer(){if(!this.mazeGameState)return;const e=`Time: ${Math.max(0,this.mazeGameState.targetTime-this.mazeGameState.survivalTime).toFixed(1)}s`;this.ctx.save(),this.ctx.fillStyle="#FFFFFF",this.ctx.font="bold 24px Arial",this.ctx.textAlign="center",this.ctx.fillText(e,this.canvas.width/2,40);const s=200,i=10,a=(this.canvas.width-s)/2,r=50,o=this.mazeGameState.survivalTime/this.mazeGameState.targetTime;this.ctx.fillStyle="#333333",this.ctx.fillRect(a,r,s,i),this.ctx.fillStyle="#00FF00",this.ctx.fillRect(a,r,s*Math.min(o,1),i),this.ctx.restore()}renderGameOverlay(){this.mazeGameState&&(this.mazeGameState.status==="won"?this.renderWinScreen():this.mazeGameState.status==="lost"&&this.renderLoseScreen())}renderWinScreen(){this.ctx.save(),this.ctx.fillStyle="rgba(0, 128, 0, 0.7)",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.ctx.fillStyle="#FFFFFF",this.ctx.font="bold 48px Arial",this.ctx.textAlign="center",this.ctx.fillText("YOU WIN!",this.canvas.width/2,this.canvas.height/2-20),this.ctx.font="24px Arial",this.ctx.fillText("You survived 30 seconds!",this.canvas.width/2,this.canvas.height/2+30),this.ctx.fillText("Press SPACE or R to restart",this.canvas.width/2,this.canvas.height/2+70),this.ctx.restore()}renderLoseScreen(){var e;this.ctx.save(),this.ctx.fillStyle="rgba(128, 0, 0, 0.7)",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.ctx.fillStyle="#FFFFFF",this.ctx.font="bold 48px Arial",this.ctx.textAlign="center",this.ctx.fillText("GAME OVER",this.canvas.width/2,this.canvas.height/2-20),this.ctx.font="24px Arial";const t=((e=this.mazeGameState)==null?void 0:e.survivalTime.toFixed(1))||"0";this.ctx.fillText(`You survived ${t} seconds`,this.canvas.width/2,this.canvas.height/2+30),this.ctx.fillText("Press SPACE or R to restart",this.canvas.width/2,this.canvas.height/2+70),this.ctx.restore()}renderDirectionIndicator(t,e,s){this.ctx.fillStyle="#FFFFFF";let i=t,a=e;switch(s){case"up":a-=4;break;case"down":a+=4;break;case"left":i-=4;break;case"right":i+=4;break}this.ctx.beginPath(),this.ctx.arc(i,a,3,0,Math.PI*2),this.ctx.fill()}renderHUD(){this.ctx.fillStyle="#333333",this.ctx.fillRect(10,10,200,20);const i=this.staminaSystem.getStaminaPercent(),a=this.staminaSystem.getIsExhausted()?"#FF4444":"#4CAF50";this.ctx.fillStyle=a,this.ctx.fillRect(12,12,196*i,16),this.ctx.fillStyle="#FFFFFF",this.ctx.font="bold 12px Arial",this.ctx.textAlign="left",this.ctx.textBaseline="middle",this.ctx.fillText(`體力: ${Math.floor(this.staminaSystem.getCurrentStamina())}/${this.staminaSystem.getMaxStamina()}`,15,10+20/2);const r=this.moneySystem.getBalance();this.ctx.fillStyle="#FFD700",this.ctx.font="bold 16px Arial",this.ctx.textAlign="left",this.ctx.fillText(`$${r}`,230,10+20/2);const o=this.playerSystem.getState(),l=this.getStateText(o);this.ctx.fillStyle="#FFFFFF",this.ctx.font="12px Arial",this.ctx.textAlign="left",this.ctx.fillText(`狀態: ${l}`,10,45),this.ctx.fillStyle="rgba(255, 255, 255, 0.6)",this.ctx.font="10px Arial",this.ctx.textAlign="left",this.ctx.fillText("WASD 移動 | Shift 跑步 | E 互動",10,this.canvas.height-10)}getStateText(t){switch(t){case"idle":return"待機";case"walking":return"步行中";case"running":return"跑步中";case"boarding":return"上車中";case"onTransport":return"乘車中";default:return t}}isInViewport(t,e,s,i){const a=this.cameraOffset.x,r=this.cameraOffset.y,o=a+this.canvas.width,l=r+this.canvas.height;return t+s>a&&t<o&&e+i>r&&e<l}}class k{constructor(t){n(this,"gameLoop");n(this,"inputHandler");n(this,"staminaSystem");n(this,"moneySystem");n(this,"playerSystem");n(this,"mapSystem");n(this,"transportSystem");n(this,"enemySystem");n(this,"renderer");n(this,"isPaused",!1);n(this,"isInitialized",!1);n(this,"mazeGameState",{status:"playing",survivalTime:0,targetTime:w.TARGET_TIME,enemies:[]});this.gameLoop=new T,this.inputHandler=new P,this.staminaSystem=new E,this.moneySystem=new I,this.mapSystem=new v,this.playerSystem=new F(this.staminaSystem,this.moneySystem,this.inputHandler),this.transportSystem=new G(this.mapSystem),this.enemySystem=new z,this.renderer=new C(t,this.mapSystem,this.playerSystem,this.staminaSystem,this.moneySystem)}init(){if(this.isInitialized){console.warn("[GameManager] Already initialized");return}console.log("[GameManager] Initializing..."),this.inputHandler.init(),this.mapSystem.init(),this.staminaSystem.init(),this.moneySystem.init(),this.playerSystem.setMapSystem(this.mapSystem);const t=this.mapSystem.getPlayerSpawnPosition();this.playerSystem.init(t),this.enemySystem.setMapSystem(this.mapSystem),this.enemySystem.spawnEnemies(t),this.transportSystem.init(),this.renderer.setEnemySystem(this.enemySystem),this.renderer.setMazeGameState(this.mazeGameState),this.gameLoop.onUpdate(e=>this.update(e)),this.gameLoop.onRender(()=>this.render()),this.isInitialized=!0,console.log("[GameManager] Initialization complete")}start(){this.isInitialized||this.init(),this.gameLoop.start(),console.log("[GameManager] Game started");const t=document.getElementById("loading");t&&(t.style.display="none")}stop(){this.gameLoop.stop(),console.log("[GameManager] Game stopped")}togglePause(){this.isPaused=!this.isPaused,console.log("[GameManager] Game",this.isPaused?"paused":"resumed")}update(t){if(this.inputHandler.isJustPressed("pause")&&this.mazeGameState.status==="playing"&&this.togglePause(),this.mazeGameState.status!=="playing"){(this.inputHandler.isJustPressed("restart")||this.inputHandler.isJustPressed("interact"))&&this.restartGame(),this.inputHandler.clearJustPressed();return}if(this.isPaused){this.inputHandler.clearJustPressed();return}if(this.mazeGameState.survivalTime+=t,this.mazeGameState.survivalTime>=this.mazeGameState.targetTime){this.mazeGameState.status="won",console.log("[GameManager] Player won! Survived",this.mazeGameState.targetTime,"seconds"),this.inputHandler.clearJustPressed();return}this.playerSystem.update(t);const e=this.playerSystem.getPosition();if(this.enemySystem.update(t,e),this.mazeGameState.enemies=this.enemySystem.getEnemies(),this.enemySystem.checkPlayerCollision(e,12)){this.mazeGameState.status="lost",console.log("[GameManager] Player lost! Caught by enemy at",this.mazeGameState.survivalTime.toFixed(1),"seconds"),this.inputHandler.clearJustPressed();return}this.inputHandler.clearJustPressed()}render(){this.renderer.setMazeGameState(this.mazeGameState),this.renderer.render()}getGameState(){return{player:this.playerSystem.getPlayer(),map:this.mapSystem.getMapData(),transports:this.transportSystem.getVehicles(),gameTime:0,isPaused:this.isPaused,isLoading:!this.isInitialized}}getMazeGameState(){return this.mazeGameState}getEnemySystem(){return this.enemySystem}restartGame(){console.log("[GameManager] Restarting game..."),this.mazeGameState={status:"playing",survivalTime:0,targetTime:w.TARGET_TIME,enemies:[]},this.mapSystem=new v,this.mapSystem.init(),this.enemySystem.reset(),this.enemySystem.setMapSystem(this.mapSystem);const t=this.mapSystem.getPlayerSpawnPosition();this.playerSystem.init(t),this.playerSystem.setMapSystem(this.mapSystem),this.enemySystem.spawnEnemies(t),this.renderer.setMapSystem(this.mapSystem),this.renderer.setEnemySystem(this.enemySystem),this.renderer.setMazeGameState(this.mazeGameState),this.isPaused=!1,console.log("[GameManager] Game restarted")}destroy(){this.gameLoop.stop(),this.inputHandler.destroy(),console.log("[GameManager] Destroyed")}}console.log("%c[MAIN.TS] Module loading started","color: green; font-weight: bold");console.log("%c[MAIN.TS] Imports successful","color: green");document.addEventListener("DOMContentLoaded",()=>{console.log("================================="),console.log("  交通捉伊人 - Transport Hide & Seek"),console.log("  Version: 0.1.0 (Sandbox Mode)"),console.log("=================================");const c=document.getElementById("game-canvas");if(!c){console.error("Failed to find game canvas element");return}c.width=m.canvas.width,c.height=m.canvas.height;const t=document.getElementById("game-container");t&&(t.style.width=`${m.canvas.width}px`,t.style.height=`${m.canvas.height}px`);const e=new k(c);e.init(),e.start(),window.game=e,console.log("Game initialized. Use window.game to access game instance."),console.log("Controls:"),console.log("  WASD / Arrow Keys - Move"),console.log("  Shift - Run"),console.log("  E - Interact (board/exit transport)"),console.log("  ESC - Pause")});
//# sourceMappingURL=index-UtqiDDst.js.map
