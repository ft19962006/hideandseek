{"version":3,"file":"index-UtqiDDst.js","sources":["../../src/config/gameConfig.ts","../../src/game/GameLoop.ts","../../src/input/InputHandler.ts","../../src/systems/StaminaSystem.ts","../../src/systems/MoneySystem.ts","../../src/systems/PlayerSystem.ts","../../src/systems/MapSystem.ts","../../src/systems/TransportSystem.ts","../../src/systems/EnemySystem.ts","../../src/rendering/Renderer.ts","../../src/game/GameManager.ts","../../src/main.ts"],"sourcesContent":["// 交通捉伊人 - Game Configuration\r\n\r\nimport { GameConfig } from '@/types';\r\n\r\nexport const gameConfig: GameConfig = {\r\n  canvas: {\r\n    width: 800,\r\n    height: 600,\r\n  },\r\n  \r\n  player: {\r\n    startPosition: { x: 10, y: 10 }, // Grid position (center of 20x20 map)\r\n    walkSpeed: 100, // pixels per second\r\n    runSpeed: 200,  // pixels per second\r\n    initialMoney: 100,\r\n    initialStamina: 100,\r\n    maxStamina: 100,\r\n  },\r\n  \r\n  stamina: {\r\n    walkCostPerSecond: 1,\r\n    runCostPerSecond: 3,\r\n    idleRecoveryPerSecond: 2,\r\n    transportRecoveryPerSecond: 1,\r\n    exhaustedSpeedMultiplier: 0.5, // 50% speed when exhausted\r\n  },\r\n  \r\n  transport: {\r\n    bus: {\r\n      speed: 200,   // 2x walk speed\r\n      cost: 10,\r\n      waitTime: 3,  // seconds at each stop\r\n    },\r\n    metro: {\r\n      speed: 300,   // 3x walk speed\r\n      cost: 20,\r\n      waitTime: 5,  // seconds at each stop\r\n    },\r\n    taxi: {\r\n      speed: 250,   // 2.5x walk speed\r\n      cost: 30,\r\n      waitTime: 0,  // instant pickup\r\n    },\r\n  },\r\n  \r\n  map: {\r\n    width: 20,      // 20 tiles wide\r\n    height: 20,     // 20 tiles tall\r\n    tileSize: 32,   // 32x32 pixels per tile\r\n  },\r\n};\r\n\r\n// Transport colors for rendering\r\nexport const transportColors = {\r\n  bus: '#4CAF50',    // Green\r\n  metro: '#2196F3',  // Blue\r\n  taxi: '#FFC107',   // Yellow\r\n};\r\n\r\n// Player colors\r\nexport const playerColors = {\r\n  fill: '#E91E63',   // Pink\r\n  stroke: '#880E4F', // Dark pink\r\n};\r\n\r\n// Map colors\r\nexport const mapColors = {\r\n  road: '#424242',\r\n  building: '#757575',\r\n  grass: '#81C784',\r\n  stop: '#FFF176',\r\n  grid: '#333333',\r\n  wall: '#000000',\r\n};\r\n\r\nexport const MAZE_CONFIG = {\r\n  WIDTH: 21,           // Must be odd for maze algorithm\r\n  HEIGHT: 21,          // Must be odd for maze algorithm\r\n  TILE_SIZE: 32,\r\n};\r\n\r\nexport const SURVIVAL_CONFIG = {\r\n  TARGET_TIME: 30,     // 30 seconds to survive\r\n  START_DELAY: 1,      // 1 second grace period at start\r\n};\r\n\r\nexport const ENEMY_CONFIG = {\r\n  SPEED: 80,           // Slower than player (player is 120)\r\n  COUNT: 2,            // Number of enemies\r\n  PATH_UPDATE_INTERVAL: 0.5,  // Update path every 0.5 seconds\r\n  MIN_SPAWN_DISTANCE: 8,      // Minimum tiles away from player spawn\r\n};\r\n","// 交通捉伊人 - Game Loop\r\n\r\nexport type UpdateCallback = (deltaTime: number) => void;\r\nexport type RenderCallback = () => void;\r\n\r\nexport class GameLoop {\r\n  private lastTime: number = 0;\r\n  private accumulatedTime: number = 0;\r\n  private readonly fixedTimeStep: number = 1000 / 60; // 60 FPS for physics\r\n  private animationFrameId: number | null = null;\r\n  private isRunning: boolean = false;\r\n  \r\n  private updateCallbacks: UpdateCallback[] = [];\r\n  private renderCallbacks: RenderCallback[] = [];\r\n  \r\n  // Performance monitoring\r\n  private fps: number = 0;\r\n  private frameCount: number = 0;\r\n  private fpsUpdateTime: number = 0;\r\n  \r\n  constructor() {\r\n    this.loop = this.loop.bind(this);\r\n  }\r\n  \r\n  /**\r\n   * Register an update callback (called with fixed time step)\r\n   */\r\n  onUpdate(callback: UpdateCallback): void {\r\n    this.updateCallbacks.push(callback);\r\n  }\r\n  \r\n  /**\r\n   * Register a render callback (called every frame)\r\n   */\r\n  onRender(callback: RenderCallback): void {\r\n    this.renderCallbacks.push(callback);\r\n  }\r\n  \r\n  /**\r\n   * Remove an update callback\r\n   */\r\n  offUpdate(callback: UpdateCallback): void {\r\n    const index = this.updateCallbacks.indexOf(callback);\r\n    if (index > -1) {\r\n      this.updateCallbacks.splice(index, 1);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Remove a render callback\r\n   */\r\n  offRender(callback: RenderCallback): void {\r\n    const index = this.renderCallbacks.indexOf(callback);\r\n    if (index > -1) {\r\n      this.renderCallbacks.splice(index, 1);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Start the game loop\r\n   */\r\n  start(): void {\r\n    if (this.isRunning) return;\r\n    \r\n    this.isRunning = true;\r\n    this.lastTime = performance.now();\r\n    this.accumulatedTime = 0;\r\n    this.fpsUpdateTime = this.lastTime;\r\n    this.frameCount = 0;\r\n    \r\n    this.animationFrameId = requestAnimationFrame(this.loop);\r\n    console.log('[GameLoop] Started');\r\n  }\r\n  \r\n  /**\r\n   * Stop the game loop\r\n   */\r\n  stop(): void {\r\n    if (!this.isRunning) return;\r\n    \r\n    this.isRunning = false;\r\n    if (this.animationFrameId !== null) {\r\n      cancelAnimationFrame(this.animationFrameId);\r\n      this.animationFrameId = null;\r\n    }\r\n    console.log('[GameLoop] Stopped');\r\n  }\r\n  \r\n  /**\r\n   * Main loop function\r\n   */\r\n  private loop(currentTime: number): void {\r\n    if (!this.isRunning) return;\r\n    \r\n    const deltaTime = currentTime - this.lastTime;\r\n    this.lastTime = currentTime;\r\n    this.accumulatedTime += deltaTime;\r\n    \r\n    // Fixed time step updates (for physics/game logic)\r\n    while (this.accumulatedTime >= this.fixedTimeStep) {\r\n      const fixedDelta = this.fixedTimeStep / 1000; // Convert to seconds\r\n      \r\n      for (const callback of this.updateCallbacks) {\r\n        callback(fixedDelta);\r\n      }\r\n      \r\n      this.accumulatedTime -= this.fixedTimeStep;\r\n    }\r\n    \r\n    // Render (every frame)\r\n    for (const callback of this.renderCallbacks) {\r\n      callback();\r\n    }\r\n    \r\n    // FPS calculation\r\n    this.frameCount++;\r\n    if (currentTime - this.fpsUpdateTime >= 1000) {\r\n      this.fps = this.frameCount;\r\n      this.frameCount = 0;\r\n      this.fpsUpdateTime = currentTime;\r\n    }\r\n    \r\n    // Schedule next frame\r\n    this.animationFrameId = requestAnimationFrame(this.loop);\r\n  }\r\n  \r\n  /**\r\n   * Get current FPS\r\n   */\r\n  getFPS(): number {\r\n    return this.fps;\r\n  }\r\n  \r\n  /**\r\n   * Check if loop is running\r\n   */\r\n  getIsRunning(): boolean {\r\n    return this.isRunning;\r\n  }\r\n}\r\n","// 交通捉伊人 - Input Handler\r\n\r\nimport { InputState } from '@/types';\r\n\r\nexport class InputHandler {\r\n  private state: InputState = {\r\n    up: false,\r\n    down: false,\r\n    left: false,\r\n    right: false,\r\n    run: false,\r\n    interact: false,\r\n    pause: false,\r\n    map: false,\r\n    restart: false,\r\n  };\r\n  \r\n  // Track which keys were just pressed this frame\r\n  private justPressed: Set<string> = new Set();\r\n  \r\n  // Key mappings\r\n  private readonly keyMap: Record<string, keyof InputState> = {\r\n    'KeyW': 'up',\r\n    'ArrowUp': 'up',\r\n    'KeyS': 'down',\r\n    'ArrowDown': 'down',\r\n    'KeyA': 'left',\r\n    'ArrowLeft': 'left',\r\n    'KeyD': 'right',\r\n    'ArrowRight': 'right',\r\n    'ShiftLeft': 'run',\r\n    'ShiftRight': 'run',\r\n    'KeyE': 'interact',\r\n    'Space': 'restart',\r\n    'KeyR': 'restart',\r\n    'Escape': 'pause',\r\n    'KeyM': 'map',\r\n  };\r\n  \r\n  constructor() {\r\n    this.handleKeyDown = this.handleKeyDown.bind(this);\r\n    this.handleKeyUp = this.handleKeyUp.bind(this);\r\n  }\r\n  \r\n  /**\r\n   * Initialize input listeners\r\n   */\r\n  init(): void {\r\n    window.addEventListener('keydown', this.handleKeyDown);\r\n    window.addEventListener('keyup', this.handleKeyUp);\r\n    console.log('[InputHandler] Initialized');\r\n  }\r\n  \r\n  /**\r\n   * Clean up input listeners\r\n   */\r\n  destroy(): void {\r\n    window.removeEventListener('keydown', this.handleKeyDown);\r\n    window.removeEventListener('keyup', this.handleKeyUp);\r\n    console.log('[InputHandler] Destroyed');\r\n  }\r\n  \r\n  /**\r\n   * Handle key down events\r\n   */\r\n  private handleKeyDown(event: KeyboardEvent): void {\r\n    const action = this.keyMap[event.code];\r\n    if (action) {\r\n      event.preventDefault();\r\n      \r\n      // Track just pressed (only on initial press, not repeat)\r\n      if (!event.repeat && !this.state[action]) {\r\n        this.justPressed.add(action);\r\n      }\r\n      \r\n      this.state[action] = true;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Handle key up events\r\n   */\r\n  private handleKeyUp(event: KeyboardEvent): void {\r\n    const action = this.keyMap[event.code];\r\n    if (action) {\r\n      event.preventDefault();\r\n      this.state[action] = false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get current input state\r\n   */\r\n  getState(): InputState {\r\n    return { ...this.state };\r\n  }\r\n  \r\n  /**\r\n   * Check if a specific input is currently pressed\r\n   */\r\n  isPressed(action: keyof InputState): boolean {\r\n    return this.state[action];\r\n  }\r\n  \r\n  /**\r\n   * Check if a specific input was just pressed this frame\r\n   */\r\n  isJustPressed(action: keyof InputState): boolean {\r\n    return this.justPressed.has(action);\r\n  }\r\n  \r\n  /**\r\n   * Clear just pressed states (call at end of each frame)\r\n   */\r\n  clearJustPressed(): void {\r\n    this.justPressed.clear();\r\n  }\r\n  \r\n  /**\r\n   * Get movement direction vector based on current input\r\n   */\r\n  getMovementVector(): { x: number; y: number } {\r\n    let x = 0;\r\n    let y = 0;\r\n    \r\n    if (this.state.left) x -= 1;\r\n    if (this.state.right) x += 1;\r\n    if (this.state.up) y -= 1;\r\n    if (this.state.down) y += 1;\r\n    \r\n    // Normalize diagonal movement\r\n    if (x !== 0 && y !== 0) {\r\n      const length = Math.sqrt(x * x + y * y);\r\n      x /= length;\r\n      y /= length;\r\n    }\r\n    \r\n    return { x, y };\r\n  }\r\n  \r\n  /**\r\n   * Check if any movement key is pressed\r\n   */\r\n  isMoving(): boolean {\r\n    return this.state.up || this.state.down || this.state.left || this.state.right;\r\n  }\r\n}\r\n","// 交通捉伊人 - Stamina System\r\n\r\nimport { PlayerState } from '@/types';\r\nimport { gameConfig } from '@/config/gameConfig';\r\n\r\nexport type StaminaChangeCallback = (current: number, max: number) => void;\r\n\r\nexport class StaminaSystem {\r\n  private currentStamina: number;\r\n  private maxStamina: number;\r\n  private isExhausted: boolean = false;\r\n  \r\n  // Callbacks for stamina changes\r\n  private changeCallbacks: StaminaChangeCallback[] = [];\r\n  \r\n  constructor() {\r\n    this.currentStamina = gameConfig.player.initialStamina;\r\n    this.maxStamina = gameConfig.player.maxStamina;\r\n  }\r\n  \r\n  /**\r\n   * Initialize the stamina system\r\n   */\r\n  init(maxStamina?: number): void {\r\n    this.maxStamina = maxStamina ?? gameConfig.player.maxStamina;\r\n    this.currentStamina = this.maxStamina;\r\n    this.isExhausted = false;\r\n    this.notifyChange();\r\n    console.log(`[StaminaSystem] Initialized with ${this.maxStamina} max stamina`);\r\n  }\r\n  \r\n  /**\r\n   * Update stamina based on player state\r\n   * @param deltaTime Time since last update in seconds\r\n   * @param playerState Current player state\r\n   */\r\n  update(deltaTime: number, playerState: PlayerState): void {\r\n    const config = gameConfig.stamina;\r\n    let staminaChange = 0;\r\n    \r\n    switch (playerState) {\r\n      case 'idle':\r\n        // Recover stamina when idle\r\n        staminaChange = config.idleRecoveryPerSecond * deltaTime;\r\n        break;\r\n        \r\n      case 'walking':\r\n        // Consume stamina when walking\r\n        staminaChange = -config.walkCostPerSecond * deltaTime;\r\n        break;\r\n        \r\n      case 'running':\r\n        // Consume more stamina when running\r\n        staminaChange = -config.runCostPerSecond * deltaTime;\r\n        break;\r\n        \r\n      case 'onTransport':\r\n        // Recover stamina while on transport\r\n        staminaChange = config.transportRecoveryPerSecond * deltaTime;\r\n        break;\r\n        \r\n      case 'boarding':\r\n        // No change during boarding\r\n        break;\r\n    }\r\n    \r\n    if (staminaChange !== 0) {\r\n      this.modifyStamina(staminaChange);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Modify stamina by a specific amount\r\n   */\r\n  private modifyStamina(amount: number): void {\r\n    const oldStamina = this.currentStamina;\r\n    this.currentStamina = Math.max(0, Math.min(this.maxStamina, this.currentStamina + amount));\r\n    \r\n    // Check for exhaustion state changes\r\n    if (this.currentStamina <= 0 && !this.isExhausted) {\r\n      this.isExhausted = true;\r\n      console.log('[StaminaSystem] Player is exhausted!');\r\n    } else if (this.currentStamina > 20 && this.isExhausted) {\r\n      // Recover from exhaustion when stamina > 20%\r\n      this.isExhausted = false;\r\n      console.log('[StaminaSystem] Player recovered from exhaustion');\r\n    }\r\n    \r\n    // Notify if stamina changed\r\n    if (Math.abs(oldStamina - this.currentStamina) > 0.01) {\r\n      this.notifyChange();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Consume a specific amount of stamina\r\n   * @returns true if consumption was successful, false if not enough stamina\r\n   */\r\n  consume(amount: number): boolean {\r\n    if (this.currentStamina >= amount) {\r\n      this.modifyStamina(-amount);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  /**\r\n   * Recover a specific amount of stamina\r\n   */\r\n  recover(amount: number): void {\r\n    this.modifyStamina(amount);\r\n  }\r\n  \r\n  /**\r\n   * Get current stamina value\r\n   */\r\n  getCurrentStamina(): number {\r\n    return this.currentStamina;\r\n  }\r\n  \r\n  /**\r\n   * Get maximum stamina value\r\n   */\r\n  getMaxStamina(): number {\r\n    return this.maxStamina;\r\n  }\r\n  \r\n  /**\r\n   * Get stamina percentage (0-1)\r\n   */\r\n  getStaminaPercent(): number {\r\n    return this.currentStamina / this.maxStamina;\r\n  }\r\n  \r\n  /**\r\n   * Check if player is exhausted\r\n   */\r\n  getIsExhausted(): boolean {\r\n    return this.isExhausted;\r\n  }\r\n  \r\n  /**\r\n   * Get speed multiplier based on exhaustion\r\n   */\r\n  getSpeedMultiplier(): number {\r\n    return this.isExhausted ? gameConfig.stamina.exhaustedSpeedMultiplier : 1;\r\n  }\r\n  \r\n  /**\r\n   * Register a callback for stamina changes\r\n   */\r\n  onChange(callback: StaminaChangeCallback): void {\r\n    this.changeCallbacks.push(callback);\r\n  }\r\n  \r\n  /**\r\n   * Remove a stamina change callback\r\n   */\r\n  offChange(callback: StaminaChangeCallback): void {\r\n    const index = this.changeCallbacks.indexOf(callback);\r\n    if (index > -1) {\r\n      this.changeCallbacks.splice(index, 1);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Notify all callbacks of stamina change\r\n   */\r\n  private notifyChange(): void {\r\n    for (const callback of this.changeCallbacks) {\r\n      callback(this.currentStamina, this.maxStamina);\r\n    }\r\n  }\r\n}\r\n","// 交通捉伊人 - Money System\r\n\r\nimport { gameConfig } from '@/config/gameConfig';\r\n\r\nexport type MoneyChangeCallback = (balance: number, change: number) => void;\r\n\r\nexport class MoneySystem {\r\n  private balance: number;\r\n  \r\n  // Callbacks for money changes\r\n  private changeCallbacks: MoneyChangeCallback[] = [];\r\n  \r\n  constructor() {\r\n    this.balance = gameConfig.player.initialMoney;\r\n  }\r\n  \r\n  /**\r\n   * Initialize the money system\r\n   */\r\n  init(startingMoney?: number): void {\r\n    this.balance = startingMoney ?? gameConfig.player.initialMoney;\r\n    this.notifyChange(0); // Initial notification\r\n    console.log(`[MoneySystem] Initialized with $${this.balance}`);\r\n  }\r\n  \r\n  /**\r\n   * Spend money\r\n   * @returns true if transaction was successful, false if insufficient funds\r\n   */\r\n  spend(amount: number): boolean {\r\n    if (amount <= 0) {\r\n      console.warn('[MoneySystem] Invalid spend amount:', amount);\r\n      return false;\r\n    }\r\n    \r\n    if (this.balance >= amount) {\r\n      this.balance -= amount;\r\n      this.notifyChange(-amount);\r\n      console.log(`[MoneySystem] Spent $${amount}, balance: $${this.balance}`);\r\n      return true;\r\n    }\r\n    \r\n    console.log(`[MoneySystem] Insufficient funds. Need $${amount}, have $${this.balance}`);\r\n    return false;\r\n  }\r\n  \r\n  /**\r\n   * Earn money\r\n   */\r\n  earn(amount: number): void {\r\n    if (amount <= 0) {\r\n      console.warn('[MoneySystem] Invalid earn amount:', amount);\r\n      return;\r\n    }\r\n    \r\n    this.balance += amount;\r\n    this.notifyChange(amount);\r\n    console.log(`[MoneySystem] Earned $${amount}, balance: $${this.balance}`);\r\n  }\r\n  \r\n  /**\r\n   * Get current balance\r\n   */\r\n  getBalance(): number {\r\n    return this.balance;\r\n  }\r\n  \r\n  /**\r\n   * Check if player can afford an amount\r\n   */\r\n  canAfford(amount: number): boolean {\r\n    return this.balance >= amount;\r\n  }\r\n  \r\n  /**\r\n   * Get cost for a specific transport type\r\n   */\r\n  getTransportCost(transportType: 'bus' | 'metro' | 'taxi'): number {\r\n    return gameConfig.transport[transportType].cost;\r\n  }\r\n  \r\n  /**\r\n   * Check if player can afford a specific transport\r\n   */\r\n  canAffordTransport(transportType: 'bus' | 'metro' | 'taxi'): boolean {\r\n    return this.canAfford(this.getTransportCost(transportType));\r\n  }\r\n  \r\n  /**\r\n   * Pay for transport\r\n   * @returns true if payment was successful\r\n   */\r\n  payForTransport(transportType: 'bus' | 'metro' | 'taxi'): boolean {\r\n    const cost = this.getTransportCost(transportType);\r\n    return this.spend(cost);\r\n  }\r\n  \r\n  /**\r\n   * Register a callback for money changes\r\n   */\r\n  onChange(callback: MoneyChangeCallback): void {\r\n    this.changeCallbacks.push(callback);\r\n  }\r\n  \r\n  /**\r\n   * Remove a money change callback\r\n   */\r\n  offChange(callback: MoneyChangeCallback): void {\r\n    const index = this.changeCallbacks.indexOf(callback);\r\n    if (index > -1) {\r\n      this.changeCallbacks.splice(index, 1);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Notify all callbacks of money change\r\n   */\r\n  private notifyChange(change: number): void {\r\n    for (const callback of this.changeCallbacks) {\r\n      callback(this.balance, change);\r\n    }\r\n  }\r\n}\r\n","// 交通捉伊人 - Player System\r\n\r\nimport { Position, PlayerState, Direction, Player } from '@/types';\r\nimport { gameConfig, MAZE_CONFIG } from '@/config/gameConfig';\r\nimport { StaminaSystem } from './StaminaSystem';\r\nimport { MoneySystem } from './MoneySystem';\r\nimport { InputHandler } from '@/input/InputHandler';\r\nimport { MapSystem } from './MapSystem';\r\n\r\nexport class PlayerSystem {\r\n  private player: Player;\r\n  private staminaSystem: StaminaSystem;\r\n  private moneySystem: MoneySystem;\r\n  private inputHandler: InputHandler;\r\n  private mapSystem: MapSystem | null = null;\r\n  \r\n  constructor(\r\n    staminaSystem: StaminaSystem,\r\n    moneySystem: MoneySystem,\r\n    inputHandler: InputHandler\r\n  ) {\r\n    this.staminaSystem = staminaSystem;\r\n    this.moneySystem = moneySystem;\r\n    this.inputHandler = inputHandler;\r\n    \r\n    // Initialize player with default values\r\n    const config = gameConfig.player;\r\n    \r\n    this.player = {\r\n      id: 'player-1',\r\n      position: { x: 0, y: 0 }, // Will be set in init\r\n      velocity: { x: 0, y: 0 },\r\n      state: 'idle',\r\n      direction: 'down',\r\n      stamina: config.initialStamina,\r\n      maxStamina: config.maxStamina,\r\n      money: config.initialMoney,\r\n      currentTransport: null,\r\n      movementSpeed: config.walkSpeed,\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Set the map system for wall collision detection\r\n   */\r\n  setMapSystem(mapSystem: MapSystem): void {\r\n    this.mapSystem = mapSystem;\r\n  }\r\n  \r\n  /**\r\n   * Initialize the player system\r\n   */\r\n  init(startPosition?: Position): void {\r\n    if (startPosition) {\r\n      this.player.position = { ...startPosition };\r\n    }\r\n    \r\n    this.player.state = 'idle';\r\n    this.player.velocity = { x: 0, y: 0 };\r\n    this.player.currentTransport = null;\r\n    \r\n    console.log('[PlayerSystem] Initialized at position:', this.player.position);\r\n  }\r\n  \r\n  /**\r\n   * Update player state\r\n   * @param deltaTime Time since last update in seconds\r\n   */\r\n  update(deltaTime: number): void {\r\n    // Don't update if on transport\r\n    if (this.player.state === 'onTransport' || this.player.state === 'boarding') {\r\n      return;\r\n    }\r\n    \r\n    // Get input\r\n    const movement = this.inputHandler.getMovementVector();\r\n    const isRunning = this.inputHandler.isPressed('run');\r\n    const isMoving = this.inputHandler.isMoving();\r\n    \r\n    // Determine player state\r\n    if (isMoving) {\r\n      // Check if can run (need stamina and not exhausted)\r\n      const canRun = isRunning && !this.staminaSystem.getIsExhausted();\r\n      this.player.state = canRun ? 'running' : 'walking';\r\n      \r\n      // Calculate speed\r\n      const baseSpeed = canRun ? gameConfig.player.runSpeed : gameConfig.player.walkSpeed;\r\n      const speed = baseSpeed * this.staminaSystem.getSpeedMultiplier();\r\n      \r\n      // Update velocity\r\n      this.player.velocity.x = movement.x * speed;\r\n      this.player.velocity.y = movement.y * speed;\r\n      \r\n      // Update direction\r\n      this.updateDirection(movement);\r\n    } else {\r\n      this.player.state = 'idle';\r\n      this.player.velocity.x = 0;\r\n      this.player.velocity.y = 0;\r\n    }\r\n    \r\n    // Update stamina based on state\r\n    this.staminaSystem.update(deltaTime, this.player.state);\r\n    \r\n    // Update position\r\n    this.updatePosition(deltaTime);\r\n    \r\n    // Sync stamina/money to player object for reference\r\n    this.player.stamina = this.staminaSystem.getCurrentStamina();\r\n    this.player.money = this.moneySystem.getBalance();\r\n  }\r\n  \r\n  /**\r\n   * Update player direction based on movement\r\n   */\r\n  private updateDirection(movement: { x: number; y: number }): void {\r\n    // Prefer horizontal direction for diagonal movement\r\n    if (Math.abs(movement.x) > Math.abs(movement.y)) {\r\n      this.player.direction = movement.x > 0 ? 'right' : 'left';\r\n    } else if (movement.y !== 0) {\r\n      this.player.direction = movement.y > 0 ? 'down' : 'up';\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Update player position with boundary and wall collision checking\r\n   */\r\n  private updatePosition(deltaTime: number): void {\r\n    const tileSize = MAZE_CONFIG.TILE_SIZE;\r\n    const mapWidth = MAZE_CONFIG.WIDTH * tileSize;\r\n    const mapHeight = MAZE_CONFIG.HEIGHT * tileSize;\r\n    const playerRadius = 10; // Half of player hitbox size\r\n    \r\n    const currentX = this.player.position.x;\r\n    const currentY = this.player.position.y;\r\n    \r\n    // Calculate proposed new positions separately for X and Y\r\n    let newX = currentX + this.player.velocity.x * deltaTime;\r\n    let newY = currentY + this.player.velocity.y * deltaTime;\r\n    \r\n    // Clamp to map boundaries first\r\n    newX = Math.max(playerRadius, Math.min(mapWidth - playerRadius, newX));\r\n    newY = Math.max(playerRadius, Math.min(mapHeight - playerRadius, newY));\r\n    \r\n    // If no map system, just apply boundary-clamped movement\r\n    if (!this.mapSystem) {\r\n      this.player.position.x = newX;\r\n      this.player.position.y = newY;\r\n      return;\r\n    }\r\n    \r\n    // Try moving in X direction only\r\n    if (this.canMoveTo(newX, currentY, playerRadius, tileSize)) {\r\n      this.player.position.x = newX;\r\n    }\r\n    \r\n    // Try moving in Y direction only\r\n    if (this.canMoveTo(this.player.position.x, newY, playerRadius, tileSize)) {\r\n      this.player.position.y = newY;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Check if the player can move to a position without colliding with walls\r\n   * Uses corner-based hitbox collision detection\r\n   */\r\n  private canMoveTo(x: number, y: number, playerRadius: number, tileSize: number): boolean {\r\n    if (!this.mapSystem) {\r\n      return true;\r\n    }\r\n    \r\n    // Check all four corners of player hitbox\r\n    const corners = [\r\n      { x: x - playerRadius, y: y - playerRadius }, // top-left\r\n      { x: x + playerRadius, y: y - playerRadius }, // top-right\r\n      { x: x - playerRadius, y: y + playerRadius }, // bottom-left\r\n      { x: x + playerRadius, y: y + playerRadius }, // bottom-right\r\n    ];\r\n    \r\n    // Check if any corner is in a wall\r\n    for (const corner of corners) {\r\n      const tileX = Math.floor(corner.x / tileSize);\r\n      const tileY = Math.floor(corner.y / tileSize);\r\n      if (!this.mapSystem.isWalkable(tileX, tileY)) {\r\n        return false;\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Board a transport vehicle\r\n   */\r\n  boardTransport(transportId: string): boolean {\r\n    if (this.player.currentTransport !== null) {\r\n      console.log('[PlayerSystem] Already on transport');\r\n      return false;\r\n    }\r\n    \r\n    this.player.currentTransport = transportId;\r\n    this.player.state = 'boarding';\r\n    this.player.velocity = { x: 0, y: 0 };\r\n    \r\n    // After boarding animation, switch to onTransport\r\n    setTimeout(() => {\r\n      if (this.player.currentTransport === transportId) {\r\n        this.player.state = 'onTransport';\r\n      }\r\n    }, 500);\r\n    \r\n    console.log('[PlayerSystem] Boarding transport:', transportId);\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Exit current transport\r\n   */\r\n  exitTransport(exitPosition: Position): void {\r\n    if (this.player.currentTransport === null) {\r\n      console.log('[PlayerSystem] Not on any transport');\r\n      return;\r\n    }\r\n    \r\n    this.player.currentTransport = null;\r\n    this.player.position = { ...exitPosition };\r\n    this.player.state = 'idle';\r\n    \r\n    console.log('[PlayerSystem] Exited transport at:', exitPosition);\r\n  }\r\n  \r\n  /**\r\n   * Set player position (used when on transport)\r\n   */\r\n  setPosition(position: Position): void {\r\n    this.player.position = { ...position };\r\n  }\r\n  \r\n  /**\r\n   * Get player position\r\n   */\r\n  getPosition(): Position {\r\n    return { ...this.player.position };\r\n  }\r\n  \r\n  /**\r\n   * Get player grid position\r\n   */\r\n  getGridPosition(): Position {\r\n    const tileSize = this.mapSystem?.getMapData().tileSize ?? MAZE_CONFIG.TILE_SIZE;\r\n    return {\r\n      x: Math.floor(this.player.position.x / tileSize),\r\n      y: Math.floor(this.player.position.y / tileSize),\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Get player state\r\n   */\r\n  getState(): PlayerState {\r\n    return this.player.state;\r\n  }\r\n  \r\n  /**\r\n   * Get player direction\r\n   */\r\n  getDirection(): Direction {\r\n    return this.player.direction;\r\n  }\r\n  \r\n  /**\r\n   * Get full player object\r\n   */\r\n  getPlayer(): Player {\r\n    return { ...this.player };\r\n  }\r\n  \r\n  /**\r\n   * Check if player is on transport\r\n   */\r\n  isOnTransport(): boolean {\r\n    return this.player.currentTransport !== null;\r\n  }\r\n  \r\n  /**\r\n   * Get current transport ID\r\n   */\r\n  getCurrentTransportId(): string | null {\r\n    return this.player.currentTransport;\r\n  }\r\n}\r\n","// 交通捉伊人 - Map System\r\n\r\nimport { Position, MapData, Tile } from '@/types';\r\nimport { MAZE_CONFIG } from '@/config/gameConfig';\r\n\r\nexport class MapSystem {\r\n  private mapData: MapData;\r\n  \r\n  constructor() {\r\n    // Initialize maze map\r\n    this.mapData = this.generateMaze();\r\n  }\r\n  \r\n  /**\r\n   * Generate a maze using Recursive Backtracking algorithm\r\n   */\r\n  private generateMaze(): MapData {\r\n    const width = MAZE_CONFIG.WIDTH;\r\n    const height = MAZE_CONFIG.HEIGHT;\r\n    const tileSize = MAZE_CONFIG.TILE_SIZE;\r\n    \r\n    // Initialize grid with all walls\r\n    const tiles: Tile[][] = [];\r\n    for (let y = 0; y < height; y++) {\r\n      tiles[y] = [];\r\n      for (let x = 0; x < width; x++) {\r\n        tiles[y][x] = {\r\n          type: 'wall',\r\n          walkable: false,\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Start from (1,1) - player spawn position\r\n    const startX = 1;\r\n    const startY = 1;\r\n    tiles[startY][startX] = {\r\n      type: 'road',\r\n      walkable: true,\r\n    };\r\n    \r\n    // Recursive carve\r\n    this.carve(startX, startY, tiles, width, height);\r\n    \r\n    return {\r\n      width,\r\n      height,\r\n      tileSize,\r\n      tiles,\r\n      stops: [], // No stops in maze mode\r\n      routes: [], // No routes in maze mode\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Recursive function to carve passages\r\n   */\r\n  private carve(x: number, y: number, tiles: Tile[][], width: number, height: number): void {\r\n    // Directions: up, down, left, right (in random order)\r\n    const directions = [\r\n      { dx: 0, dy: -2 },\r\n      { dx: 0, dy: 2 },\r\n      { dx: -2, dy: 0 },\r\n      { dx: 2, dy: 0 }\r\n    ].sort(() => Math.random() - 0.5);\r\n    \r\n    for (const { dx, dy } of directions) {\r\n      const newX = x + dx;\r\n      const newY = y + dy;\r\n      \r\n      // Check if newX, newY is within bounds and is a wall\r\n      if (newX > 0 && newX < width && newY > 0 && newY < height && tiles[newY][newX].type === 'wall') {\r\n        // Carve the wall between current and new cell\r\n          const midX = x + Math.floor(dx / 2);\r\n          const midY = y + Math.floor(dy / 2);\r\n          tiles[midY][midX] = {\r\n            type: 'road',\r\n            walkable: true,\r\n          };\r\n        tiles[newY][newX] = {\r\n          type: 'road',\r\n          walkable: true,\r\n        };\r\n        \r\n        this.carve(newX, newY, tiles, width, height);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Initialize the map system\r\n   */\r\n  init(): void {\r\n    console.log('[MapSystem] Initialized maze map');\r\n  }\r\n  \r\n  /**\r\n   * Get map data\r\n   */\r\n  getMapData(): MapData {\r\n    return this.mapData;\r\n  }\r\n  \r\n  /**\r\n   * Get tile at grid position\r\n   */\r\n  getTile(gridX: number, gridY: number): Tile | null {\r\n    if (gridX < 0 || gridX >= this.mapData.width || \r\n        gridY < 0 || gridY >= this.mapData.height) {\r\n      return null;\r\n    }\r\n    return this.mapData.tiles[gridY][gridX];\r\n  }\r\n  \r\n  /**\r\n   * Get tile at world position\r\n   */\r\n  getTileAtWorld(worldX: number, worldY: number): Tile | null {\r\n    const gridX = Math.floor(worldX / this.mapData.tileSize);\r\n    const gridY = Math.floor(worldY / this.mapData.tileSize);\r\n    return this.getTile(gridX, gridY);\r\n  }\r\n  \r\n  /**\r\n   * Check if position is walkable\r\n   */\r\n  isWalkable(gridX: number, gridY: number): boolean {\r\n    const tile = this.getTile(gridX, gridY);\r\n    return tile ? tile.walkable : false;\r\n  }\r\n  \r\n  /**\r\n   * Get player spawn position in pixels (center of tile 1,1)\r\n   */\r\n  getPlayerSpawnPosition(): Position {\r\n    return this.gridToWorld(1, 1);\r\n  }\r\n  \r\n  /**\r\n   * Convert grid position to world position (center of tile)\r\n   */\r\n  gridToWorld(gridX: number, gridY: number): Position {\r\n    const tileSize = this.mapData.tileSize;\r\n    return {\r\n      x: gridX * tileSize + tileSize / 2,\r\n      y: gridY * tileSize + tileSize / 2,\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Convert world position to grid position\r\n   */\r\n  worldToGrid(worldX: number, worldY: number): Position {\r\n    return {\r\n      x: Math.floor(worldX / this.mapData.tileSize),\r\n      y: Math.floor(worldY / this.mapData.tileSize),\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Get map dimensions in pixels\r\n   */\r\n  getWorldSize(): { width: number; height: number } {\r\n    return {\r\n      width: this.mapData.width * this.mapData.tileSize,\r\n      height: this.mapData.height * this.mapData.tileSize,\r\n    };\r\n  }\r\n}\r\n","// 交通捉伊人 - Transport System (Disabled for Maze Mode)\r\n\r\nimport { Position, TransportVehicle } from '@/types';\r\nimport { MapSystem } from './MapSystem';\r\n\r\nexport type TransportEventCallback = (event: any) => void;\r\n\r\nexport class TransportSystem {\r\n  constructor(_mapSystem: MapSystem) {}\r\n  \r\n  init(): void {\r\n    console.log('[TransportSystem] Disabled for Maze Mode');\r\n  }\r\n  \r\n  update(_deltaTime: number): void {}\r\n  \r\n  getVehicles(): TransportVehicle[] {\r\n    return [];\r\n  }\r\n  \r\n  getVehicle(_vehicleId: string): TransportVehicle | undefined {\r\n    return undefined;\r\n  }\r\n  \r\n  getAvailableVehiclesAtStop(_stopId: string): TransportVehicle[] {\r\n    return [];\r\n  }\r\n  \r\n  boardVehicle(_playerId: string, _vehicleId: string): boolean {\r\n    return false;\r\n  }\r\n  \r\n  exitVehicle(_playerId: string, _vehicleId: string): Position | null {\r\n    return null;\r\n  }\r\n  \r\n  getVehiclePosition(_vehicleId: string): Position | null {\r\n    return null;\r\n  }\r\n  \r\n  isVehicleAtStop(_vehicleId: string): boolean {\r\n    return false;\r\n  }\r\n  \r\n  onEvent(_callback: TransportEventCallback): void {}\r\n}\r\n","// 交通捉伊人 - Enemy System\r\n// Implements enemy AI with chasing behavior for maze survival mode\r\n\r\nimport { Enemy, Position } from '@/types';\r\nimport { ENEMY_CONFIG, MAZE_CONFIG } from '@/config/gameConfig';\r\nimport { MapSystem } from './MapSystem';\r\n\r\nexport class EnemySystem {\r\n  private enemies: Enemy[] = [];\r\n  private mapSystem: MapSystem | null = null;\r\n  \r\n  /**\r\n   * Set the map system reference for wall collision detection\r\n   */\r\n  setMapSystem(mapSystem: MapSystem): void {\r\n    this.mapSystem = mapSystem;\r\n  }\r\n  \r\n  /**\r\n   * Spawn enemies at valid positions away from the player\r\n   */\r\n  spawnEnemies(playerSpawn: Position): void {\r\n    this.enemies = [];\r\n    \r\n    if (!this.mapSystem) {\r\n      console.error('[EnemySystem] MapSystem not set, cannot spawn enemies');\r\n      return;\r\n    }\r\n    \r\n    for (let i = 0; i < ENEMY_CONFIG.COUNT; i++) {\r\n      const spawnPos = this.findValidSpawnPosition(playerSpawn);\r\n      \r\n      if (spawnPos) {\r\n        const enemy: Enemy = {\r\n          x: spawnPos.x,\r\n          y: spawnPos.y,\r\n          velocityX: 0,\r\n          velocityY: 0,\r\n          speed: ENEMY_CONFIG.SPEED,\r\n          targetX: spawnPos.x,\r\n          targetY: spawnPos.y,\r\n          pathUpdateTimer: 0,\r\n        };\r\n        this.enemies.push(enemy);\r\n        console.log(`[EnemySystem] Spawned enemy ${i + 1} at (${spawnPos.x.toFixed(0)}, ${spawnPos.y.toFixed(0)})`);\r\n      } else {\r\n        console.warn(`[EnemySystem] Could not find valid spawn position for enemy ${i + 1}`);\r\n      }\r\n    }\r\n    \r\n    console.log(`[EnemySystem] Spawned ${this.enemies.length} enemies`);\r\n  }\r\n  \r\n  /**\r\n   * Find a valid spawn position for an enemy\r\n   * Must be on a 'road' tile and at least MIN_SPAWN_DISTANCE tiles away from player\r\n   */\r\n  private findValidSpawnPosition(playerSpawn: Position): Position | null {\r\n    if (!this.mapSystem) {\r\n      return null;\r\n    }\r\n    \r\n    const mapData = this.mapSystem.getMapData();\r\n    const tileSize = MAZE_CONFIG.TILE_SIZE;\r\n    const minDistanceTiles = ENEMY_CONFIG.MIN_SPAWN_DISTANCE;\r\n    \r\n    // Convert player spawn to grid position\r\n    const playerGridX = Math.floor(playerSpawn.x / tileSize);\r\n    const playerGridY = Math.floor(playerSpawn.y / tileSize);\r\n    \r\n    // Collect all valid spawn positions\r\n    const validPositions: Position[] = [];\r\n    \r\n    for (let y = 0; y < mapData.height; y++) {\r\n      for (let x = 0; x < mapData.width; x++) {\r\n        const tile = mapData.tiles[y][x];\r\n        \r\n        // Must be a road tile (walkable)\r\n        if (tile.type !== 'road' || !tile.walkable) {\r\n          continue;\r\n        }\r\n        \r\n        // Calculate tile distance from player spawn (Manhattan distance in tiles)\r\n        const tileDistX = Math.abs(x - playerGridX);\r\n        const tileDistY = Math.abs(y - playerGridY);\r\n        const tileDistance = Math.sqrt(tileDistX * tileDistX + tileDistY * tileDistY);\r\n        \r\n        // Must be at least MIN_SPAWN_DISTANCE tiles away\r\n        if (tileDistance >= minDistanceTiles) {\r\n          // Convert to world position (center of tile)\r\n          validPositions.push({\r\n            x: x * tileSize + tileSize / 2,\r\n            y: y * tileSize + tileSize / 2,\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Randomly pick from valid positions\r\n    if (validPositions.length === 0) {\r\n      return null;\r\n    }\r\n    \r\n    const randomIndex = Math.floor(Math.random() * validPositions.length);\r\n    return validPositions[randomIndex];\r\n  }\r\n  \r\n  /**\r\n   * Update all enemies - chase the player\r\n   */\r\n  update(deltaTime: number, playerPos: Position): void {\r\n    for (const enemy of this.enemies) {\r\n      this.updateEnemy(enemy, playerPos, deltaTime);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Update a single enemy's position using chase AI\r\n   */\r\n  private updateEnemy(enemy: Enemy, playerPos: Position, deltaTime: number): void {\r\n    // Calculate direction to player\r\n    const dx = playerPos.x - enemy.x;\r\n    const dy = playerPos.y - enemy.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    \r\n    if (distance > 0) {\r\n      // Normalize direction\r\n      const dirX = dx / distance;\r\n      const dirY = dy / distance;\r\n      \r\n      // Calculate new position\r\n      const speed = enemy.speed;\r\n      const newX = enemy.x + dirX * speed * deltaTime;\r\n      const newY = enemy.y + dirY * speed * deltaTime;\r\n      \r\n      // Enemy radius for collision detection (~10 pixels)\r\n      const enemyRadius = 10;\r\n      \r\n      // Check wall collision before moving\r\n      if (this.canMoveTo(newX, newY, enemyRadius)) {\r\n        enemy.x = newX;\r\n        enemy.y = newY;\r\n        enemy.velocityX = dirX * speed;\r\n        enemy.velocityY = dirY * speed;\r\n      } else {\r\n        // Try moving in just X or just Y direction (wall avoidance)\r\n        if (this.canMoveTo(newX, enemy.y, enemyRadius)) {\r\n          enemy.x = newX;\r\n          enemy.velocityX = dirX * speed;\r\n          enemy.velocityY = 0;\r\n        } else if (this.canMoveTo(enemy.x, newY, enemyRadius)) {\r\n          enemy.y = newY;\r\n          enemy.velocityX = 0;\r\n          enemy.velocityY = dirY * speed;\r\n        } else {\r\n          // Can't move at all\r\n          enemy.velocityX = 0;\r\n          enemy.velocityY = 0;\r\n        }\r\n      }\r\n      \r\n      // Update target position (for potential rendering)\r\n      enemy.targetX = playerPos.x;\r\n      enemy.targetY = playerPos.y;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Check if an enemy can move to a position without hitting walls\r\n   * Uses corner-based hitbox collision similar to player\r\n   */\r\n  private canMoveTo(x: number, y: number, radius: number): boolean {\r\n    if (!this.mapSystem) {\r\n      return false;\r\n    }\r\n    \r\n    const tileSize = MAZE_CONFIG.TILE_SIZE;\r\n    \r\n    // Check all four corners of the enemy's hitbox\r\n    const corners = [\r\n      { x: x - radius, y: y - radius }, // top-left\r\n      { x: x + radius, y: y - radius }, // top-right\r\n      { x: x - radius, y: y + radius }, // bottom-left\r\n      { x: x + radius, y: y + radius }, // bottom-right\r\n    ];\r\n    \r\n    for (const corner of corners) {\r\n      const gridX = Math.floor(corner.x / tileSize);\r\n      const gridY = Math.floor(corner.y / tileSize);\r\n      \r\n      if (!this.mapSystem.isWalkable(gridX, gridY)) {\r\n        return false;\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Get all enemies\r\n   */\r\n  getEnemies(): Enemy[] {\r\n    return this.enemies;\r\n  }\r\n  \r\n  /**\r\n   * Check if any enemy is colliding with the player\r\n   * Returns true if collision detected (game over condition)\r\n   */\r\n  checkPlayerCollision(playerPos: Position, playerRadius: number): boolean {\r\n    const enemyRadius = 10;\r\n    \r\n    for (const enemy of this.enemies) {\r\n      const dx = playerPos.x - enemy.x;\r\n      const dy = playerPos.y - enemy.y;\r\n      const distance = Math.sqrt(dx * dx + dy * dy);\r\n      \r\n      // Collision if distance is less than sum of radii\r\n      const collisionDistance = playerRadius + enemyRadius;\r\n      if (distance < collisionDistance) {\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n  \r\n  /**\r\n   * Reset all enemies (for game restart)\r\n   */\r\n  reset(): void {\r\n    this.enemies = [];\r\n  }\r\n}\r\n","// 交通捉伊人 - Canvas Renderer\r\n\r\nimport { Position, PlayerState, Direction, MazeGameState } from '@/types';\r\nimport { gameConfig, mapColors, playerColors } from '@/config/gameConfig';\r\nimport { MapSystem } from '@/systems/MapSystem';\r\nimport { PlayerSystem } from '@/systems/PlayerSystem';\r\nimport { StaminaSystem } from '@/systems/StaminaSystem';\r\nimport { MoneySystem } from '@/systems/MoneySystem';\r\nimport { EnemySystem } from '@/systems/EnemySystem';\r\n\r\nexport class Renderer {\r\n  private canvas: HTMLCanvasElement;\r\n  private ctx: CanvasRenderingContext2D;\r\n  private mapSystem: MapSystem;\r\n  private playerSystem: PlayerSystem;\r\n  private staminaSystem: StaminaSystem;\r\n  private moneySystem: MoneySystem;\r\n  private enemySystem: EnemySystem | null = null;\r\n  private mazeGameState: MazeGameState | null = null;\r\n  \r\n  // Camera for viewport\r\n  private cameraOffset: Position = { x: 0, y: 0 };\r\n  \r\n  constructor(\r\n    canvas: HTMLCanvasElement,\r\n    mapSystem: MapSystem,\r\n    playerSystem: PlayerSystem,\r\n    staminaSystem: StaminaSystem,\r\n    moneySystem: MoneySystem\r\n  ) {\r\n    this.canvas = canvas;\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) {\r\n      throw new Error('Failed to get 2D context');\r\n    }\r\n    this.ctx = ctx;\r\n    \r\n    this.mapSystem = mapSystem;\r\n    this.playerSystem = playerSystem;\r\n    this.staminaSystem = staminaSystem;\r\n    this.moneySystem = moneySystem;\r\n    \r\n    // Set canvas size\r\n    this.resize(gameConfig.canvas.width, gameConfig.canvas.height);\r\n  }\r\n  \r\n  /**\r\n   * Resize canvas\r\n   */\r\n  resize(width: number, height: number): void {\r\n    this.canvas.width = width;\r\n    this.canvas.height = height;\r\n  }\r\n  \r\n  /**\r\n   * Set MapSystem reference for rendering map\r\n   */\r\n  setMapSystem(mapSystem: MapSystem): void {\r\n    this.mapSystem = mapSystem;\r\n  }\r\n  \r\n  /**\r\n   * Set EnemySystem reference for rendering enemies\r\n   */\r\n  setEnemySystem(enemySystem: EnemySystem): void {\r\n    this.enemySystem = enemySystem;\r\n  }\r\n  \r\n  /**\r\n   * Set MazeGameState reference for rendering game state\r\n   */\r\n  setMazeGameState(state: MazeGameState): void {\r\n    this.mazeGameState = state;\r\n  }\r\n  \r\n  /**\r\n   * Main render function\r\n   */\r\n  render(): void {\r\n    // Clear canvas\r\n    this.ctx.fillStyle = '#1a1a2e';\r\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    \r\n    // Update camera to follow player\r\n    this.updateCamera();\r\n    \r\n    // Save context state\r\n    this.ctx.save();\r\n    \r\n    // Apply camera transform\r\n    this.ctx.translate(-this.cameraOffset.x, -this.cameraOffset.y);\r\n    \r\n    // Render layers\r\n    this.renderMap();\r\n    // this.renderStops();\r\n    // this.renderTransports();\r\n    this.renderPlayer();\r\n    this.renderEnemies();\r\n    \r\n    // Restore context state\r\n    this.ctx.restore();\r\n    \r\n    // Render HUD (not affected by camera)\r\n    this.renderHUD();\r\n    this.renderSurvivalTimer();\r\n    this.renderGameOverlay();\r\n  }\r\n  \r\n  /**\r\n   * Update camera to follow player\r\n   */\r\n  private updateCamera(): void {\r\n    const playerPos = this.playerSystem.getPosition();\r\n    const mapSize = this.mapSystem.getWorldSize();\r\n    \r\n    // Center camera on player\r\n    let targetX = playerPos.x - this.canvas.width / 2;\r\n    let targetY = playerPos.y - this.canvas.height / 2;\r\n    \r\n    // Clamp to map boundaries\r\n    targetX = Math.max(0, Math.min(mapSize.width - this.canvas.width, targetX));\r\n    targetY = Math.max(0, Math.min(mapSize.height - this.canvas.height, targetY));\r\n    \r\n    // Smooth camera follow\r\n    this.cameraOffset.x += (targetX - this.cameraOffset.x) * 0.1;\r\n    this.cameraOffset.y += (targetY - this.cameraOffset.y) * 0.1;\r\n  }\r\n  \r\n  /**\r\n   * Render the map grid\r\n   */\r\n  private renderMap(): void {\r\n    const mapData = this.mapSystem.getMapData();\r\n    const tileSize = mapData.tileSize;\r\n    \r\n    for (let y = 0; y < mapData.height; y++) {\r\n      for (let x = 0; x < mapData.width; x++) {\r\n        const tile = mapData.tiles[y][x];\r\n        const worldX = x * tileSize;\r\n        const worldY = y * tileSize;\r\n        \r\n        // Skip tiles outside viewport\r\n        if (!this.isInViewport(worldX, worldY, tileSize, tileSize)) {\r\n          continue;\r\n        }\r\n        \r\n        // Draw tile\r\n        switch (tile.type) {\r\n          case 'road':\r\n            this.ctx.fillStyle = mapColors.road;\r\n            break;\r\n          case 'wall':\r\n            this.ctx.fillStyle = mapColors.wall;\r\n            break;\r\n          case 'building':\r\n            this.ctx.fillStyle = mapColors.building;\r\n            break;\r\n          case 'grass':\r\n            this.ctx.fillStyle = mapColors.grass;\r\n            break;\r\n          case 'stop':\r\n            this.ctx.fillStyle = mapColors.stop;\r\n            break;\r\n          default:\r\n            this.ctx.fillStyle = mapColors.road;\r\n        }\r\n        \r\n        this.ctx.fillRect(worldX, worldY, tileSize, tileSize);\r\n        \r\n        // Draw grid lines\r\n        this.ctx.strokeStyle = mapColors.grid;\r\n        this.ctx.lineWidth = 1;\r\n        this.ctx.strokeRect(worldX, worldY, tileSize, tileSize);\r\n      }\r\n    }\r\n  }\r\n  \r\n  \r\n  /**\r\n   * Render the player\r\n   */\r\n  private renderPlayer(): void {\r\n    const player = this.playerSystem.getPlayer();\r\n    const { x, y } = player.position;\r\n    \r\n    this.ctx.save();\r\n    \r\n    // Player shadow\r\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\r\n    this.ctx.beginPath();\r\n    this.ctx.ellipse(x, y + 12, 10, 4, 0, 0, Math.PI * 2);\r\n    this.ctx.fill();\r\n    \r\n    // Player body (circle)\r\n    this.ctx.fillStyle = playerColors.fill;\r\n    this.ctx.strokeStyle = playerColors.stroke;\r\n    this.ctx.lineWidth = 2;\r\n    \r\n    this.ctx.beginPath();\r\n    this.ctx.arc(x, y, 12, 0, Math.PI * 2);\r\n    this.ctx.fill();\r\n    this.ctx.stroke();\r\n    \r\n    // Direction indicator\r\n    this.renderDirectionIndicator(x, y, player.direction);\r\n    \r\n    // State indicator (running effect)\r\n    if (player.state === 'running') {\r\n      this.ctx.strokeStyle = '#FFD700';\r\n      this.ctx.lineWidth = 2;\r\n      this.ctx.setLineDash([4, 4]);\r\n      this.ctx.beginPath();\r\n      this.ctx.arc(x, y, 16, 0, Math.PI * 2);\r\n      this.ctx.stroke();\r\n      this.ctx.setLineDash([]);\r\n    }\r\n    \r\n    this.ctx.restore();\r\n  }\r\n  \r\n  /**\r\n   * Render enemies as red circles\r\n   */\r\n  private renderEnemies(): void {\r\n    if (!this.enemySystem) return;\r\n    \r\n    const enemies = this.enemySystem.getEnemies();\r\n    this.ctx.save();\r\n    \r\n    for (const enemy of enemies) {\r\n      // Draw enemy as red circle (camera transform already applied)\r\n      this.ctx.fillStyle = '#FF0000';\r\n      this.ctx.beginPath();\r\n      this.ctx.arc(enemy.x, enemy.y, 12, 0, Math.PI * 2);\r\n      this.ctx.fill();\r\n      \r\n      // Add glow effect\r\n      this.ctx.strokeStyle = '#FF6666';\r\n      this.ctx.lineWidth = 2;\r\n      this.ctx.stroke();\r\n    }\r\n    \r\n    this.ctx.restore();\r\n  }\r\n  \r\n  /**\r\n   * Render survival timer at top center\r\n   */\r\n  private renderSurvivalTimer(): void {\r\n    if (!this.mazeGameState) return;\r\n    \r\n    const timeRemaining = Math.max(0,\r\n      this.mazeGameState.targetTime - this.mazeGameState.survivalTime\r\n    );\r\n    const timeText = `Time: ${timeRemaining.toFixed(1)}s`;\r\n    \r\n    this.ctx.save();\r\n    this.ctx.fillStyle = '#FFFFFF';\r\n    this.ctx.font = 'bold 24px Arial';\r\n    this.ctx.textAlign = 'center';\r\n    this.ctx.fillText(timeText, this.canvas.width / 2, 40);\r\n    \r\n    // Progress bar\r\n    const barWidth = 200;\r\n    const barHeight = 10;\r\n    const barX = (this.canvas.width - barWidth) / 2;\r\n    const barY = 50;\r\n    const progress = this.mazeGameState.survivalTime / this.mazeGameState.targetTime;\r\n    \r\n    // Background\r\n    this.ctx.fillStyle = '#333333';\r\n    this.ctx.fillRect(barX, barY, barWidth, barHeight);\r\n    \r\n    // Progress fill (green)\r\n    this.ctx.fillStyle = '#00FF00';\r\n    this.ctx.fillRect(barX, barY, barWidth * Math.min(progress, 1), barHeight);\r\n    \r\n    this.ctx.restore();\r\n  }\r\n  \r\n  /**\r\n   * Render game overlay (win/lose screens)\r\n   */\r\n  private renderGameOverlay(): void {\r\n    if (!this.mazeGameState) return;\r\n    \r\n    if (this.mazeGameState.status === 'won') {\r\n      this.renderWinScreen();\r\n    } else if (this.mazeGameState.status === 'lost') {\r\n      this.renderLoseScreen();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Render win screen overlay\r\n   */\r\n  private renderWinScreen(): void {\r\n    this.ctx.save();\r\n    // Semi-transparent green overlay\r\n    this.ctx.fillStyle = 'rgba(0, 128, 0, 0.7)';\r\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    \r\n    // Win text\r\n    this.ctx.fillStyle = '#FFFFFF';\r\n    this.ctx.font = 'bold 48px Arial';\r\n    this.ctx.textAlign = 'center';\r\n    this.ctx.fillText('YOU WIN!', this.canvas.width / 2, this.canvas.height / 2 - 20);\r\n    \r\n    this.ctx.font = '24px Arial';\r\n    this.ctx.fillText('You survived 30 seconds!', this.canvas.width / 2, this.canvas.height / 2 + 30);\r\n    this.ctx.fillText('Press SPACE or R to restart', this.canvas.width / 2, this.canvas.height / 2 + 70);\r\n    this.ctx.restore();\r\n  }\r\n  \r\n  /**\r\n   * Render lose screen overlay\r\n   */\r\n  private renderLoseScreen(): void {\r\n    this.ctx.save();\r\n    // Semi-transparent red overlay\r\n    this.ctx.fillStyle = 'rgba(128, 0, 0, 0.7)';\r\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    \r\n    // Lose text\r\n    this.ctx.fillStyle = '#FFFFFF';\r\n    this.ctx.font = 'bold 48px Arial';\r\n    this.ctx.textAlign = 'center';\r\n    this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 20);\r\n    \r\n    this.ctx.font = '24px Arial';\r\n    const time = this.mazeGameState?.survivalTime.toFixed(1) || '0';\r\n    this.ctx.fillText(`You survived ${time} seconds`, this.canvas.width / 2, this.canvas.height / 2 + 30);\r\n    this.ctx.fillText('Press SPACE or R to restart', this.canvas.width / 2, this.canvas.height / 2 + 70);\r\n    this.ctx.restore();\r\n  }\r\n  \r\n  /**\r\n   * Render direction indicator on player\r\n   */\r\n  private renderDirectionIndicator(x: number, y: number, direction: Direction): void {\r\n    this.ctx.fillStyle = '#FFFFFF';\r\n    \r\n    let indicatorX = x;\r\n    let indicatorY = y;\r\n    \r\n    switch (direction) {\r\n      case 'up':\r\n        indicatorY -= 4;\r\n        break;\r\n      case 'down':\r\n        indicatorY += 4;\r\n        break;\r\n      case 'left':\r\n        indicatorX -= 4;\r\n        break;\r\n      case 'right':\r\n        indicatorX += 4;\r\n        break;\r\n    }\r\n    \r\n    this.ctx.beginPath();\r\n    this.ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);\r\n    this.ctx.fill();\r\n  }\r\n  \r\n  /**\r\n   * Render HUD (heads-up display)\r\n   */\r\n  private renderHUD(): void {\r\n    const padding = 10;\r\n    const barWidth = 200;\r\n    const barHeight = 20;\r\n    \r\n    // Stamina bar background\r\n    this.ctx.fillStyle = '#333333';\r\n    this.ctx.fillRect(padding, padding, barWidth, barHeight);\r\n    \r\n    // Stamina bar fill\r\n    const staminaPercent = this.staminaSystem.getStaminaPercent();\r\n    const staminaColor = this.staminaSystem.getIsExhausted() ? '#FF4444' : '#4CAF50';\r\n    this.ctx.fillStyle = staminaColor;\r\n    this.ctx.fillRect(padding + 2, padding + 2, (barWidth - 4) * staminaPercent, barHeight - 4);\r\n    \r\n    // Stamina text\r\n    this.ctx.fillStyle = '#FFFFFF';\r\n    this.ctx.font = 'bold 12px Arial';\r\n    this.ctx.textAlign = 'left';\r\n    this.ctx.textBaseline = 'middle';\r\n    this.ctx.fillText(\r\n      `體力: ${Math.floor(this.staminaSystem.getCurrentStamina())}/${this.staminaSystem.getMaxStamina()}`,\r\n      padding + 5,\r\n      padding + barHeight / 2\r\n    );\r\n    \r\n    // Money display\r\n    const money = this.moneySystem.getBalance();\r\n    this.ctx.fillStyle = '#FFD700';\r\n    this.ctx.font = 'bold 16px Arial';\r\n    this.ctx.textAlign = 'left';\r\n    this.ctx.fillText(`$${money}`, padding + barWidth + 20, padding + barHeight / 2);\r\n    \r\n    // Player state\r\n    const state = this.playerSystem.getState();\r\n    const stateText = this.getStateText(state);\r\n    this.ctx.fillStyle = '#FFFFFF';\r\n    this.ctx.font = '12px Arial';\r\n    this.ctx.textAlign = 'left';\r\n    this.ctx.fillText(`狀態: ${stateText}`, padding, padding + barHeight + 15);\r\n    \r\n    // Controls hint\r\n    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';\r\n    this.ctx.font = '10px Arial';\r\n    this.ctx.textAlign = 'left';\r\n    this.ctx.fillText('WASD 移動 | Shift 跑步 | E 互動', padding, this.canvas.height - 10);\r\n    \r\n  }\r\n  \r\n  /**\r\n   * Get display text for player state\r\n   */\r\n  private getStateText(state: PlayerState): string {\r\n    switch (state) {\r\n      case 'idle': return '待機';\r\n      case 'walking': return '步行中';\r\n      case 'running': return '跑步中';\r\n      case 'boarding': return '上車中';\r\n      case 'onTransport': return '乘車中';\r\n      default: return state;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Check if a rectangle is in the viewport\r\n   */\r\n  private isInViewport(x: number, y: number, width: number, height: number): boolean {\r\n    const viewLeft = this.cameraOffset.x;\r\n    const viewTop = this.cameraOffset.y;\r\n    const viewRight = viewLeft + this.canvas.width;\r\n    const viewBottom = viewTop + this.canvas.height;\r\n    \r\n    return x + width > viewLeft && x < viewRight &&\r\n           y + height > viewTop && y < viewBottom;\r\n  }\r\n}\r\n","// 交通捉伊人 - Game Manager (Maze Survival Mode)\r\n\r\nimport { GameState, MazeGameState } from '@/types';\r\nimport { SURVIVAL_CONFIG } from '@/config/gameConfig';\r\nimport { GameLoop } from './GameLoop';\r\nimport { InputHandler } from '@/input/InputHandler';\r\nimport { StaminaSystem } from '@/systems/StaminaSystem';\r\nimport { MoneySystem } from '@/systems/MoneySystem';\r\nimport { PlayerSystem } from '@/systems/PlayerSystem';\r\nimport { MapSystem } from '@/systems/MapSystem';\r\nimport { TransportSystem } from '@/systems/TransportSystem';\r\nimport { EnemySystem } from '@/systems/EnemySystem';\r\nimport { Renderer } from '@/rendering/Renderer';\r\n\r\nexport class GameManager {\r\n  private gameLoop: GameLoop;\r\n  private inputHandler: InputHandler;\r\n  private staminaSystem: StaminaSystem;\r\n  private moneySystem: MoneySystem;\r\n  private playerSystem: PlayerSystem;\r\n  private mapSystem: MapSystem;\r\n  private transportSystem: TransportSystem;\r\n  private enemySystem: EnemySystem;\r\n  private renderer: Renderer;\r\n  \r\n  private isPaused: boolean = false;\r\n  private isInitialized: boolean = false;\r\n  \r\n  // Maze survival game state\r\n  private mazeGameState: MazeGameState = {\r\n    status: 'playing',\r\n    survivalTime: 0,\r\n    targetTime: SURVIVAL_CONFIG.TARGET_TIME,\r\n    enemies: []\r\n  };\r\n  \r\n  \r\n  constructor(canvas: HTMLCanvasElement) {\r\n    // Create systems\r\n    this.gameLoop = new GameLoop();\r\n    this.inputHandler = new InputHandler();\r\n    this.staminaSystem = new StaminaSystem();\r\n    this.moneySystem = new MoneySystem();\r\n    this.mapSystem = new MapSystem();\r\n    \r\n    // Player system needs other systems\r\n    this.playerSystem = new PlayerSystem(\r\n      this.staminaSystem,\r\n      this.moneySystem,\r\n      this.inputHandler\r\n    );\r\n    \r\n    // Transport system needs map system\r\n    this.transportSystem = new TransportSystem(this.mapSystem);\r\n    \r\n    // Enemy system for maze survival mode\r\n    this.enemySystem = new EnemySystem();\r\n    \r\n    // Renderer needs all systems\r\n    this.renderer = new Renderer(\r\n      canvas,\r\n      this.mapSystem,\r\n      this.playerSystem,\r\n      this.staminaSystem,\r\n      this.moneySystem\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * Initialize all game systems\r\n   */\r\n  init(): void {\r\n    if (this.isInitialized) {\r\n      console.warn('[GameManager] Already initialized');\r\n      return;\r\n    }\r\n    \r\n    console.log('[GameManager] Initializing...');\r\n    \r\n    // Initialize all systems\r\n    this.inputHandler.init();\r\n    this.mapSystem.init();\r\n    this.staminaSystem.init();\r\n    this.moneySystem.init();\r\n    \r\n    // Connect map system to player system for wall collision detection\r\n    this.playerSystem.setMapSystem(this.mapSystem);\r\n    \r\n    // Initialize player at spawn position\r\n    const spawnPos = this.mapSystem.getPlayerSpawnPosition();\r\n    this.playerSystem.init(spawnPos);\r\n    \r\n    // Initialize enemy system for maze survival\r\n    this.enemySystem.setMapSystem(this.mapSystem);\r\n    this.enemySystem.spawnEnemies(spawnPos);\r\n    \r\n    this.transportSystem.init();\r\n    \r\n    // Connect renderer to enemy system and game state\r\n    this.renderer.setEnemySystem(this.enemySystem);\r\n    this.renderer.setMazeGameState(this.mazeGameState);\r\n    \r\n    // Set up transport event handlers (Disabled for Maze Mode)\r\n    // this.transportSystem.onEvent((event) => { ... });\r\n    \r\n    // Register game loop callbacks\r\n    this.gameLoop.onUpdate((deltaTime) => this.update(deltaTime));\r\n    this.gameLoop.onRender(() => this.render());\r\n    \r\n    this.isInitialized = true;\r\n    console.log('[GameManager] Initialization complete');\r\n  }\r\n  \r\n  /**\r\n   * Start the game\r\n   */\r\n  start(): void {\r\n    if (!this.isInitialized) {\r\n      this.init();\r\n    }\r\n    \r\n    this.gameLoop.start();\r\n    console.log('[GameManager] Game started');\r\n    \r\n    // Hide loading indicator\r\n    const loadingEl = document.getElementById('loading');\r\n    if (loadingEl) {\r\n      loadingEl.style.display = 'none';\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Stop the game\r\n   */\r\n  stop(): void {\r\n    this.gameLoop.stop();\r\n    console.log('[GameManager] Game stopped');\r\n  }\r\n  \r\n  /**\r\n   * Pause/unpause the game\r\n   */\r\n  togglePause(): void {\r\n    this.isPaused = !this.isPaused;\r\n    console.log('[GameManager] Game', this.isPaused ? 'paused' : 'resumed');\r\n  }\r\n  \r\n  /**\r\n   * Main update function\r\n   */\r\n  private update(deltaTime: number): void {\r\n    // Handle pause toggle (only when playing)\r\n    if (this.inputHandler.isJustPressed('pause') && this.mazeGameState.status === 'playing') {\r\n      this.togglePause();\r\n    }\r\n    \r\n    // Handle restart when game is over (won or lost)\r\n    if (this.mazeGameState.status !== 'playing') {\r\n      if (this.inputHandler.isJustPressed('restart') || this.inputHandler.isJustPressed('interact')) {\r\n        this.restartGame();\r\n      }\r\n      this.inputHandler.clearJustPressed();\r\n      return;\r\n    }\r\n    \r\n    if (this.isPaused) {\r\n      this.inputHandler.clearJustPressed();\r\n      return;\r\n    }\r\n    \r\n    // Update survival timer\r\n    this.mazeGameState.survivalTime += deltaTime;\r\n    \r\n    // Check win condition - survived target time\r\n    if (this.mazeGameState.survivalTime >= this.mazeGameState.targetTime) {\r\n      this.mazeGameState.status = 'won';\r\n      console.log('[GameManager] Player won! Survived', this.mazeGameState.targetTime, 'seconds');\r\n      this.inputHandler.clearJustPressed();\r\n      return;\r\n    }\r\n    \r\n    // Update player\r\n    this.playerSystem.update(deltaTime);\r\n    \r\n    // Update enemies\r\n    const playerPos = this.playerSystem.getPosition();\r\n    this.enemySystem.update(deltaTime, playerPos);\r\n    \r\n    // Update enemies array reference in mazeGameState\r\n    this.mazeGameState.enemies = this.enemySystem.getEnemies();\r\n    \r\n    // Check lose condition - enemy touched player\r\n    const playerRadius = 12; // Must match renderer size\r\n    if (this.enemySystem.checkPlayerCollision(playerPos, playerRadius)) {\r\n      this.mazeGameState.status = 'lost';\r\n      console.log('[GameManager] Player lost! Caught by enemy at', this.mazeGameState.survivalTime.toFixed(1), 'seconds');\r\n      this.inputHandler.clearJustPressed();\r\n      return;\r\n    }\r\n    \r\n    // Clear just pressed states at end of frame\r\n    this.inputHandler.clearJustPressed();\r\n  }\r\n  \r\n  // Legacy transport methods removed - Maze Mode only\r\n  \r\n  /**\r\n   * Main render function\r\n   */\r\n  private render(): void {\r\n    // Before rendering, ensure renderer has current state\r\n    this.renderer.setMazeGameState(this.mazeGameState);\r\n    \r\n    // Renderer handles all rendering including overlays\r\n    this.renderer.render();\r\n  }\r\n  \r\n  /**\r\n   * Get current game state\r\n   */\r\n  getGameState(): GameState {\r\n    return {\r\n      player: this.playerSystem.getPlayer(),\r\n      map: this.mapSystem.getMapData(),\r\n      transports: this.transportSystem.getVehicles(),\r\n      gameTime: 0, // TODO: implement game timer\r\n      isPaused: this.isPaused,\r\n      isLoading: !this.isInitialized,\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Get maze game state (survival mode)\r\n   */\r\n  getMazeGameState(): MazeGameState {\r\n    return this.mazeGameState;\r\n  }\r\n  \r\n  /**\r\n   * Get enemy system\r\n   */\r\n  getEnemySystem(): EnemySystem {\r\n    return this.enemySystem;\r\n  }\r\n  \r\n  /**\r\n   * Restart the game (for maze survival mode)\r\n   */\r\n  restartGame(): void {\r\n    console.log('[GameManager] Restarting game...');\r\n    \r\n    // Reset maze game state\r\n    this.mazeGameState = {\r\n      status: 'playing',\r\n      survivalTime: 0,\r\n      targetTime: SURVIVAL_CONFIG.TARGET_TIME,\r\n      enemies: []\r\n    };\r\n    \r\n    // Regenerate maze\r\n    this.mapSystem = new MapSystem();\r\n    this.mapSystem.init();\r\n    \r\n    // Reset enemy system with new map\r\n    this.enemySystem.reset();\r\n    this.enemySystem.setMapSystem(this.mapSystem);\r\n    \r\n    // Reset player at new spawn position\r\n    const playerSpawn = this.mapSystem.getPlayerSpawnPosition();\r\n    this.playerSystem.init(playerSpawn);\r\n    this.playerSystem.setMapSystem(this.mapSystem);\r\n    \r\n    // Spawn enemies away from player\r\n    this.enemySystem.spawnEnemies(playerSpawn);\r\n    \r\n    // Re-connect renderer after restart\r\n    this.renderer.setMapSystem(this.mapSystem);\r\n    this.renderer.setEnemySystem(this.enemySystem);\r\n    this.renderer.setMazeGameState(this.mazeGameState);\r\n    \r\n    // Reset pause state\r\n    this.isPaused = false;\r\n    \r\n    console.log('[GameManager] Game restarted');\r\n  }\r\n  \r\n  /**\r\n   * Clean up resources\r\n   */\r\n  destroy(): void {\r\n    this.gameLoop.stop();\r\n    this.inputHandler.destroy();\r\n    console.log('[GameManager] Destroyed');\r\n  }\r\n}\r\n","// 交通捉伊人 - Main Entry Point\r\n// Transport Hide and Seek - A lightweight web game\r\n\r\nconsole.log('%c[MAIN.TS] Module loading started', 'color: green; font-weight: bold');\r\n\r\nimport './styles.css';\r\nimport { GameManager } from '@/game/GameManager';\r\nimport { gameConfig } from '@/config/gameConfig';\r\n\r\nconsole.log('%c[MAIN.TS] Imports successful', 'color: green');\r\n\r\n// Initialize the game when DOM is ready\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  console.log('=================================');\r\n  console.log('  交通捉伊人 - Transport Hide & Seek');\r\n  console.log('  Version: 0.1.0 (Sandbox Mode)');\r\n  console.log('=================================');\r\n  \r\n  // Get canvas element\r\n  const canvas = document.getElementById('game-canvas') as HTMLCanvasElement;\r\n  if (!canvas) {\r\n    console.error('Failed to find game canvas element');\r\n    return;\r\n  }\r\n  \r\n  // Set canvas size\r\n  canvas.width = gameConfig.canvas.width;\r\n  canvas.height = gameConfig.canvas.height;\r\n  \r\n  // Update container size to match\r\n  const container = document.getElementById('game-container');\r\n  if (container) {\r\n    container.style.width = `${gameConfig.canvas.width}px`;\r\n    container.style.height = `${gameConfig.canvas.height}px`;\r\n  }\r\n  \r\n  // Create and start game\r\n  const game = new GameManager(canvas);\r\n  \r\n  // Initialize and start\r\n  game.init();\r\n  game.start();\r\n  \r\n  // Expose game instance for debugging\r\n  (window as unknown as { game: GameManager }).game = game;\r\n  \r\n  console.log('Game initialized. Use window.game to access game instance.');\r\n  console.log('Controls:');\r\n  console.log('  WASD / Arrow Keys - Move');\r\n  console.log('  Shift - Run');\r\n  console.log('  E - Interact (board/exit transport)');\r\n  console.log('  ESC - Pause');\r\n});\r\n"],"names":["gameConfig","playerColors","mapColors","MAZE_CONFIG","SURVIVAL_CONFIG","ENEMY_CONFIG","GameLoop","__publicField","callback","index","currentTime","deltaTime","fixedDelta","InputHandler","event","action","x","y","length","StaminaSystem","maxStamina","playerState","config","staminaChange","amount","oldStamina","MoneySystem","startingMoney","transportType","cost","change","PlayerSystem","staminaSystem","moneySystem","inputHandler","mapSystem","startPosition","movement","isRunning","canRun","speed","tileSize","mapWidth","mapHeight","playerRadius","currentX","currentY","newX","newY","corners","corner","tileX","tileY","transportId","exitPosition","position","_a","MapSystem","width","height","tiles","startX","startY","directions","dx","dy","midX","midY","gridX","gridY","worldX","worldY","tile","TransportSystem","_mapSystem","_deltaTime","_vehicleId","_stopId","_playerId","_callback","EnemySystem","playerSpawn","i","spawnPos","enemy","mapData","minDistanceTiles","playerGridX","playerGridY","validPositions","tileDistX","tileDistY","randomIndex","playerPos","distance","dirX","dirY","enemyRadius","radius","collisionDistance","Renderer","canvas","playerSystem","ctx","enemySystem","state","mapSize","targetX","targetY","player","enemies","timeText","barWidth","barHeight","barX","barY","progress","time","direction","indicatorX","indicatorY","staminaPercent","staminaColor","money","stateText","viewLeft","viewTop","viewRight","viewBottom","GameManager","loadingEl","container","game"],"mappings":"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"}